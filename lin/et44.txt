
تعدد مؤشرات الترابط في بايثون | المجموعة 2 (التزامن)
مستوى الصعوبة: متوسط
آخر تحديث: 28 أغسطس 2019
تتناول هذه المقالة مفهوم مزامنة مؤشر الترابط في حالة تعدد مؤشرات الترابط في لغة برمجة بايثون.

التزامن بين الخيوط

يتم تعريف مزامنة الخيط كآلية تضمن أن اثنين أو أكثر من الخيوط المتزامنة لا تقوم في نفس الوقت بتنفيذ جزء معين من البرنامج يعرف بالقسم الحرج .

يشير القسم الحرج إلى أجزاء البرنامج حيث يتم الوصول إلى المورد المشترك.

على سبيل المثال ، في الرسم البياني أدناه ، تحاول 3 سلاسل محادثات الوصول إلى الموارد المشتركة أو القسم الحرج في نفس الوقت.


يمكن أن تؤدي عمليات الوصول المتزامنة إلى الموارد المشتركة إلى حالة السباق .

تحدث حالة السباق عندما يتمكن اثنان أو أكثر من مؤشرات الترابط من الوصول إلى البيانات المشتركة ومحاولة تغييرها في نفس الوقت. نتيجة لذلك ، قد تكون قيم المتغيرات غير متوقعة وتختلف تبعًا لتوقيتات تبديل السياق للعمليات.

ضع في اعتبارك البرنامج أدناه لفهم مفهوم حالة السباق:


import threading
  
# global variable x
x = 0
  
def increment():
    """
    function to increment global variable x
    """
    global x
    x += 1
  
def thread_task():
    """
    task for thread
    calls increment function 100000 times.
    """
    for _ in range(100000):
        increment()
  
def main_task():
    global x
    # setting global variable x as 0
    x = 0
  
    # creating threads
    t1 = threading.Thread(target=thread_task)
    t2 = threading.Thread(target=thread_task)
  
    # start threads
    t1.start()
    t2.start()
  
    # wait until threads finish their job
    t1.join()
    t2.join()
  
if __name__ == "__main__":
    for i in range(10):
        main_task()
        print("Iteration {0}: x = {1}".format(i,x))
انتاج:

التكرار 0: س = 175005
التكرار 1: س = 200000
التكرار 2: س = 200000
التكرار 3: س = 169432
التكرار 4: س = 153316
التكرار 5: س = 200000
التكرار 6: س = 167322
التكرار 7: س = 200000
التكرار 8: س = 169917
التكرار 9: س = 153589
في البرنامج أعلاه:

يتم إنشاء خيطين t1 و t2 في دالة main_task ويتم تعيين المتغير العام x على 0.
يحتوي كل مؤشر ترابط على دالة thread_task المستهدفة حيث يتم استدعاء وظيفة الزيادة 100000 مرة.
ستزيد وظيفة الزيادة المتغير العام x بمقدار 1 في كل استدعاء.
القيمة النهائية المتوقعة لـ x هي 200000 ولكن ما نحصل عليه في 10 تكرارات لوظيفة main_task هو بعض القيم المختلفة.

يحدث هذا بسبب الوصول المتزامن للخيوط إلى المتغير المشترك x . عدم القدرة على التنبؤ في قيمة x ليس سوى حالة عرقية .

فيما يلي رسم تخطيطي يوضح كيف يمكن أن تحدث حالة السباق في البرنامج أعلاه:


لاحظ أن القيمة المتوقعة لـ x في الرسم البياني أعلاه هي 12 ولكن نظرًا لظروف السباق ، اتضح أنها 11!

ومن ثم ، نحتاج إلى أداة للمزامنة المناسبة بين خيوط متعددة.

باستخدام الأقفال

توفر وحدة الخيوط فئة Lock للتعامل مع ظروف السباق. يتم تطبيق القفل باستخدام كائن Semaphore الذي يوفره نظام التشغيل.

السيمافور هو كائن مزامنة يتحكم في الوصول من خلال عمليات / خيوط متعددة إلى مورد مشترك في بيئة برمجة متوازية. إنها ببساطة قيمة في مكان مخصص في تخزين نظام التشغيل (أو kernel) يمكن لكل عملية / مؤشر ترابط التحقق منها ثم تغييرها. اعتمادًا على القيمة التي تم العثور عليها ، يمكن للعملية / مؤشر الترابط استخدام المورد أو ستجد أنه قيد الاستخدام بالفعل ويجب الانتظار لبعض الوقت قبل المحاولة مرة أخرى. يمكن أن تكون الإشارات ثنائية (0 أو 1) أو يمكن أن تحتوي على قيم إضافية. عادة ، تقوم العملية / الخيط باستخدام الإشارات بالتحقق من القيمة وبعد ذلك ، إذا كانت تستخدم المورد ، تقوم بتغيير القيمة لتعكس ذلك بحيث يعرف مستخدمو الإشارات اللاحقة الانتظار.

توفر فئة القفل الطرق التالية:

اكتساب ([حظر]): للحصول على قفل. يمكن أن يكون القفل محظورًا أو غير محظور.
عند الاستدعاء مع تعيين وسيطة الحظر على True (الافتراضي) ، يتم حظر تنفيذ مؤشر الترابط حتى يتم إلغاء قفل القفل ، ثم يتم تعيين القفل على Lock والعودة إلى True .
عند الاستدعاء مع تعيين وسيطة الحظر على False ، لا يتم حظر تنفيذ مؤشر الترابط. إذا كان القفل غير مقفل ، فاضبطه على القفل وأعد True else return False على الفور.
الافراج (): لتحرير القفل.
عندما يتم قفل القفل ، أعد ضبطه لفتحه ، ثم أعده. إذا تم حظر أي مؤشرات ترابط أخرى في انتظار إلغاء قفل القفل ، اسمح لواحد منهم بالضبط بالمتابعة.
إذا تم إلغاء قفل القفل بالفعل ، فسيتم رفع خطأ ThreadError .
ضع في اعتبارك المثال الوارد أدناه:


import threading
  
# global variable x
x = 0
  
def increment():
    """
    function to increment global variable x
    """
    global x
    x += 1
  
def thread_task(lock):
    """
    task for thread
    calls increment function 100000 times.
    """
    for _ in range(100000):
        lock.acquire()
        increment()
        lock.release()
  
def main_task():
    global x
    # setting global variable x as 0
    x = 0
  
    # creating a lock
    lock = threading.Lock()
  
    # creating threads
    t1 = threading.Thread(target=thread_task, args=(lock,))
    t2 = threading.Thread(target=thread_task, args=(lock,))
  
    # start threads
    t1.start()
    t2.start()
  
    # wait until threads finish their job
    t1.join()
    t2.join()
  
if __name__ == "__main__":
    for i in range(10):
        main_task()
        print("Iteration {0}: x = {1}".format(i,x))
انتاج:

التكرار 0: x = 200000
التكرار 1: س = 200000
التكرار 2: س = 200000
التكرار 3: س = 200000
التكرار 4: س = 200000
التكرار 5: س = 200000
التكرار 6: س = 200000
التكرار 7: س = 200000
التكرار 8: س = 200000
التكرار 9: س = 200000
دعونا نحاول فهم الكود أعلاه خطوة بخطوة:

أولاً ، يتم إنشاء كائن Lock باستخدام:
  قفل = خيوط.
بعد ذلك ، يتم تمرير lock كوسيطة دالة الهدف:
  t1 = مؤشر الترابط. الخيط (الهدف = thread_task ، args = (قفل ،))
  t2 = مؤشر الترابط. الخيط (الهدف = thread_task ، args = (قفل ،))
في القسم الحرج من الوظيفة الهدف ، نطبق القفل باستخدام طريقة lock.acquire () . بمجرد الحصول على قفل ، لا يمكن لأي مؤشر ترابط آخر الوصول إلى القسم الحرج (هنا ، وظيفة الزيادة ) حتى يتم تحرير القفل باستخدام طريقة lock.release () .
  lock.acquire ()
  زيادة راتب()
  lock.release ()
كما ترى في النتائج ، تظهر القيمة النهائية لـ x لتكون 200000 في كل مرة (وهي النتيجة النهائية المتوقعة).

فيما يلي رسم تخطيطي موضح أدناه والذي يصور تنفيذ الأقفال في البرنامج أعلاه:


هذا يقودنا إلى نهاية هذه السلسلة التعليمية حول Multithreading في Python .
أخيرًا ، إليك بعض مزايا وعيوب تعدد مؤشرات الترابط:

مزايا:

لا يحظر المستخدم. هذا لأن الخيوط مستقلة عن بعضها البعض.
يمكن استخدام موارد النظام بشكل أفضل نظرًا لأن الخيوط تنفذ المهام بشكل متوازي.
أداء مُحسَّن على الأجهزة متعددة المعالجات.
تستخدم الخوادم متعددة الخيوط وواجهة المستخدم الرسومية التفاعلية تعدد مؤشرات الترابط حصريًا.
سلبيات:

مع زيادة عدد الخيوط ، يزداد التعقيد.
تزامن الموارد المشتركة (الأشياء ، البيانات) ضروري.
من الصعب التصحيح ، والنتيجة في بعض الأحيان غير متوقعة.
المآزق المحتملة التي تؤدي إلى المجاعة ، أي قد لا يتم تقديم بعض الخيوط بتصميم سيئ
بناء ومزامنة الخيوط هو وحدة المعالجة المركزية / الذاكرة.