
البرمجة الوظيفية في بايثون
مستوى الصعوبة: صعب
آخر تحديث: 11 أكتوبر 2021
البرمجة الوظيفية هي نموذج برمجة نحاول فيه ربط كل شيء بأسلوب وظائف رياضية بحتة. إنه نوع تعريفي من أسلوب البرمجة. ينصب تركيزها الرئيسي على " ما يجب حله " على عكس أسلوب الأمر حيث يكون التركيز الرئيسي هو " كيفية الحل ". يستخدم التعبيرات بدلا من البيانات. يتم تقييم التعبير لإنتاج قيمة بينما يتم تنفيذ العبارة لتعيين المتغيرات.

مفاهيم البرمجة الوظيفية
من المتوقع أن تتبع أي لغة برمجة وظيفية هذه المفاهيم.

وظائف خالصة: هذه الوظائف لها خاصيتان رئيسيتان. أولاً ، ينتجون دائمًا نفس الناتج لنفس الحجج بغض النظر عن أي شيء آخر. ثانيًا ، ليس لديهم أي آثار جانبية ، أي أنهم يقومون بتعديل أي وسيطة أو متغيرات عامة أو ينتجون شيئًا ما.
العودية: لا توجد حلقة "for" أو "while" في اللغات الوظيفية. يتم تنفيذ التكرار في اللغات الوظيفية من خلال العودية.
الوظائف من الدرجة الأولى ويمكن أن تكون من الدرجة الأولى: يتم التعامل مع وظائف الدرجة الأولى كمتغير من الدرجة الأولى. يمكن تمرير متغيرات الدرجة الأولى إلى الوظائف كمعامل ، ويمكن إرجاعها من الوظائف أو تخزينها في هياكل البيانات.
المتغيرات غير قابلة للتغيير: في البرمجة الوظيفية ، لا يمكننا تعديل متغير بعد تهيئته. يمكننا إنشاء متغيرات جديدة - لكن لا يمكننا تعديل المتغيرات الحالية.
البرمجة الوظيفية في بايثون
تدعم Python أيضًا نماذج البرمجة الوظيفية دون دعم أي ميزات أو مكتبات خاصة.

وظائف خالصة
كما تمت مناقشته أعلاه ، فإن الوظائف البحتة لها خاصيتان.

دائمًا ما ينتج نفس الإخراج لنفس الوسيطات. على سبيل المثال ، 3 + 7 ستكون دائمًا 10 بغض النظر عن أي شيء.
لا يغير أو يعدل متغير الإدخال.
تُعرف الخاصية الثانية أيضًا باسم الثبات. النتيجة الوحيدة للدالة النقية هي القيمة التي ترجعها. هم حتمية. من السهل تصحيح البرامج التي تتم باستخدام البرمجة الوظيفية لأن الوظائف الصرفة ليس لها آثار جانبية أو مخفية في الإدخال / الإخراج. تعمل الوظائف البحتة أيضًا على تسهيل كتابة التطبيقات المتوازية / المتزامنة. عندما تتم كتابة الكود بهذا النمط ، يمكن للمترجم الذكي القيام بالعديد من الأشياء - يمكنه موازنة التعليمات ، والانتظار لتقييم النتائج عند الحاجة إليها ، وحفظ النتائج لأن النتائج لا تتغير أبدًا طالما أن الإدخال لا يتغير.

مثال:


# Python program to demonstrate
# pure functions
  
  
# A pure function that does Not
# changes the input list and 
# returns the new List
def pure_func(List):
      
    New_List = []
      
    for i in List:
        New_List.append(i**2)
          
    return New_List
      
# Driver's code
Original_List = [1, 2, 3, 4]
Modified_List = pure_func(Original_List)
  
print("Original List:", Original_List)
print("Modified List:", Modified_List)
انتاج:

القائمة الأصلية: [1، 2، 3، 4]
القائمة المعدلة: [1 ، 4 ، 9 ، 16]
العودية
أثناء البرمجة الوظيفية ، لا يوجد مفهوم forالحلقة أو whileالحلقة ، وبدلاً من ذلك يتم استخدام العودية. العودية هي عملية تستدعي فيها الوظيفة نفسها بشكل مباشر أو غير مباشر. في البرنامج العودي ، يتم توفير حل الحالة الأساسية ويتم التعبير عن حل المشكلة الأكبر من حيث المشكلات الأصغر. قد ينشأ سؤال ما هي الحالة الأساسية؟ يمكن اعتبار الحالة الأساسية كشرط يخبر المترجم أو المترجم الفوري بالخروج من الوظيفة.

ملاحظة: لمزيد من المعلومات ، راجع العودية

مثال: دعنا نفكر في برنامج سيجد مجموع كل عناصر القائمة دون استخدام أي حلقة for.


# Python program to demonstrate
# recursion
  
  
# Recursive Function to find
# sum of a list
def Sum(L, i, n, count):
      
    # Base case
    if n <= i:
        return count
      
    count += L[i]
      
    # Going into the recursion
    count = Sum(L, i + 1, n, count)
      
    return count
      
# Driver's code
L = [1, 2, 3, 4, 5]
count = 0
n = len(L)
print(Sum(L, 0, n, count))
انتاج:

15
الوظائف من الدرجة الأولى ويمكن أن تكون من مرتبة أعلى
يتم التعامل مع أشياء من الدرجة الأولى بشكل موحد طوال الوقت. قد يتم تخزينها في هياكل البيانات ، أو تمريرها كوسيطات ، أو استخدامها في هياكل التحكم. يقال إن لغة البرمجة تدعم وظائف من الدرجة الأولى إذا تعاملت مع الوظائف على أنها كائنات من الدرجة الأولى.

خصائص وظائف الدرجة الأولى:

الوظيفة هي مثيل لنوع الكائن.
يمكنك تخزين الوظيفة في متغير.
يمكنك تمرير الوظيفة كمعامل إلى وظيفة أخرى.
يمكنك إعادة الوظيفة من وظيفة.
يمكنك تخزينها في هياكل البيانات مثل جداول التجزئة والقوائم ...

# Python program to demonstrate
# higher order functions
  
  
def shout(text): 
    return text.upper() 
    
def whisper(text): 
    return text.lower() 
    
def greet(func): 
    # storing the function in a variable 
    greeting = func("Hi, I am created by a function passed as an argument.") 
    print(greeting)  
    
greet(shout) 
greet(whisper) 
انتاج:

مرحبًا ، لقد خلقت بواسطة وظيفة مرت كحجة.
مرحبًا ، لقد خلقت من خلال وظيفة تم تمريرها كوسيطة.
ملاحظة: لمزيد من المعلومات ، راجع وظائف First Class في Python .

وظائف مدمجة ذات ترتيب أعلى

لجعل معالجة الكائنات القابلة للتكرار مثل القوائم والمكرر أسهل بكثير ، نفذت Python بعض وظائف الترتيب الأعلى شائعة الاستخدام. ترجع هذه الوظائف مكررًا موفرًا للمساحة. بعض الوظائف المضمنة ذات الترتيب الأعلى هي:

Map (): تُرجع الدالة map () قائمة بالنتائج بعد تطبيق الوظيفة المعينة على كل عنصر في عنصر تكراري معين (قائمة ، مجموعة ، إلخ.)
التركيب اللغوي: map (fun، iter)

البارامترات:
مرح: إنها وظيفة تمرر إليها الخريطة كل عنصر من العناصر القابلة للتكرار.
iter: هو تكرار يتم تعيينه على الخريطة.

نوع الإرجاع: إرجاع مكرر لفئة الخريطة.

مثال:


# Python program to demonstrate working 
# of map. 
    
# Return double of n 
def addition(n): 
    return n + n 
    
# We double all numbers using map() 
numbers = (1, 2, 3, 4) 
results = map(addition, numbers) 
  
# Does not Print the value
print(results)
  
# For Printing value
for result in results:
    print(result, end = " ")
انتاج:

<كائن الخريطة في 0x7fae3004b630>
2 4 6 8
ملاحظة: لمزيد من المعلومات ، راجع وظيفة خريطة بايثون ()

مرشح (): تقوم طريقة المرشح () بتصفية التسلسل المحدد بمساعدة وظيفة تختبر كل عنصر في التسلسل ليكون صحيحًا أم لا.
بناء الجملة: مرشح (وظيفة ، تسلسل)

المعلمات:
وظيفة: وظيفة تختبر ما إذا كان كل عنصر من عناصر التسلسل صحيحًا أم لا.
التسلسل: التسلسل الذي يجب تصفيته ، يمكن أن يكون مجموعات أو قوائم أو مجموعات أو حاويات لأي مكررات.

نوع الإرجاع: إرجاع مكرر تمت تصفيته بالفعل.

مثال:


# Python program to demonstrate working 
# of the filter. 
    
# function that filters vowels 
def fun(variable): 
      
    letters = ['a', 'e', 'i', 'o', 'u'] 
      
    if (variable in letters): 
        return True
    else: 
        return False
    
    
# sequence 
sequence = ['g', 'e', 'e', 'j', 'k', 's', 'p', 'r'] 
    
# using filter function 
filtered = filter(fun, sequence) 
    
print('The filtered letters are:') 
  
for s in filtered: 
    print(s) 
انتاج:

الحروف المصفاة هي:
ه
ه
ملاحظة: لمزيد من المعلومات ، راجع عامل التصفية () في بايثون

وظائف Lambda: في Python ، تعني الوظيفة المجهولة أن الوظيفة بدون اسم. كما نعلم بالفعل ، يتم استخدام الكلمة الأساسية def لتحديد الوظائف العادية ويتم استخدام الكلمة الأساسية lambda لإنشاء وظائف مجهولة.
بناء الجملة:

حجج لامدا: التعبير
1) يمكن أن تحتوي هذه الوظيفة على أي عدد من الوسيطات ولكن تعبير واحد فقط يتم تقييمه وإرجاعه.
2) واحد مجاني لاستخدام وظائف lambda حيثما كانت الكائنات الوظيفية مطلوبة.
3) يجب أن تظل على علم بأن وظائف lambda مقصورة من الناحية التركيبية على تعبير واحد.
4) لها استخدامات مختلفة في مجالات معينة من البرمجة إلى جانب أنواع أخرى من التعبيرات في الوظائف.

مثال:


# Python code to demonstrate
# lambda
  
    
cube = lambda x: x * x*x 
print(cube(7)) 
    
    
L = [1, 3, 2, 4, 5, 6]
is_even = [x for x in L if x % 2 == 0]
  
print(is_even)  
انتاج:

343
[2، 4، 6]
ملاحظة: لمزيد من المعلومات ، راجع Python lambda .

ثبات
الثبات هو نموذج برمجة وظيفي يمكن استخدامه لتصحيح الأخطاء لأنه سيؤدي إلى حدوث خطأ حيث يتم تغيير المتغير وليس حيث يتم تغيير القيمة. يدعم Python أيضًا بعض أنواع البيانات غير القابلة للتغيير مثل السلسلة ، tuple ، الرقمية ، إلخ.

مثال:


# Python program to demonstrate 
# immutable data types
    
  
# String data types
immutable = "GeeksforGeeks"
  
# changing the values will
# raise an error
immutable[1] = 'K'
انتاج:

Traceback (آخر مكالمة أخيرة):
  ملف "/home/ee8bf8d8f560b97c7ec0ef080a077879.py" ، السطر 10 ، في
    غير قابل للتغيير [1] = 'K'
TypeError: الكائن "str" ​​لا يدعم تعيين العنصر
الفرق بين البرمجة الوظيفية والبرمجة الشيئية
تعد اللغات الموجهة للكائنات جيدة عندما يكون لديك مجموعة ثابتة من العمليات على الأشياء ، ومع تطور التعليمات البرمجية الخاصة بك ، فإنك تقوم في المقام الأول بإضافة أشياء جديدة. يمكن تحقيق ذلك عن طريق إضافة فئات جديدة تنفذ الأساليب الحالية ، ويتم ترك الفئات الموجودة بمفردها.

تكون اللغات الوظيفية جيدة عندما يكون لديك مجموعة ثابتة من الأشياء ، ومع تطور شفرتك ، فإنك تضيف بشكل أساسي عمليات جديدة على الأشياء الموجودة. يمكن تحقيق ذلك عن طريق إضافة وظائف جديدة تحسب مع أنواع البيانات الموجودة ، ويتم ترك الوظائف الحالية بمفردها.

البرمجة الوظيفية	البرمجة الشيئية
يؤكد نموذج البرمجة هذا على استخدام الوظائف حيث تؤدي كل وظيفة مهمة محددة.	يعتمد نموذج البرمجة هذا على مفهوم موجه للكائنات. يتم استخدام الفئات حيث يتم إنشاء مثيل للكائنات
العناصر الأساسية المستخدمة هي المتغيرات والوظائف ، والبيانات الموجودة في الوظائف غير قابلة للتغيير (لا يمكن تغييرها بعد الإنشاء).	العناصر الأساسية المستخدمة هي الكائنات والطرق والبيانات المستخدمة هنا هي بيانات قابلة للتغيير.
يتبع نموذج البرمجة التوضيحي.	يتبع نموذج البرمجة الحتمية.
يستخدم العودية للتكرار.	يستخدم الحلقات للتكرار.
إنها برمجة موازية مدعومة.	لا يدعم البرمجة المتوازية.
لا تحتاج العبارات في نموذج البرمجة هذا إلى اتباع ترتيب معين أثناء التنفيذ.	تحتاج البيانات في نموذج البرمجة هذا إلى اتباع ترتيب ، أي نهج من أسفل إلى أعلى أثناء التنفيذ.
