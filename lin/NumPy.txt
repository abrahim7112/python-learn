
برنامج NumPy التعليمي
مستوى الصعوبة: سهل
آخر تحديث: 07 مايو 2021
Python NumPy عبارة عن حزمة معالجة مصفوفة للأغراض العامة توفر أدوات للتعامل مع المصفوفات ذات الأبعاد n. يوفر أدوات حسابية متنوعة مثل الوظائف الرياضية الشاملة وإجراءات الجبر الخطي. يوفر NumPy مرونة Python وسرعة كود C المحسن جيدًا. من السهل استخدام بناء الجملة مما يجعله سهل الوصول إليه ومنتجًا للمبرمجين من أي خلفية.

يساعدك هذا البرنامج التعليمي NumPy على تعلم أساسيات NumPy من الأساسيات إلى Advance ، مثل العمليات على مصفوفة NumPy والمصفوفات التي تستخدم مجموعة بيانات ضخمة من NumPy - البرامج والمشاريع.

برنامج Python NumPy التعليمي

المقالات الأخيرة على NumPy !!

مقدمة
مقدمة إلى نومبي
لغة Python NumPy
مصفوفة NumPy في بايثون
أساسيات مصفوفات NumPy
تسرد Python صفائف VS Numpy
نومبي - ndarray
نوع البيانات Object (dtype) في NumPy Python
إنشاء مصفوفة NumPy
Numpy - إنشاء صفيف
طريقة ارانج
الطريقة الصفرية
قم بإنشاء مصفوفة Numpy مليئة بكل منها
طريقة لينسبيس
طريقة العين
دالة Numpy Meshgrid
إنشاء مصفوفة NumPy أحادية البعد
كيفية إنشاء مصفوفة NumPy فارغة وكاملة؟
قم بإنشاء مصفوفة Numpy مليئة بجميع الأصفار
قم بإنشاء مصفوفة Numpy مليئة بكل منها
كيفية إنشاء مصفوفة غاوسية ثنائية الأبعاد باستخدام NumPy؟
كيفية إنشاء متجه في Python باستخدام NumPy
إنشاء مجموعة السجلات من قائمة السجلات الفردية
معالجة صفيف NumPy
نسخ وعرض في NumPy Array
كيفية نسخ مصفوفة NumPy إلى مصفوفة أخرى؟
إلحاق القيم في نهاية مصفوفة NumPy
كيفية تبديل أعمدة مصفوفة NumPy معينة؟
أدخل محورًا جديدًا داخل مصفوفة NumPy
تكديس تسلسل مصفوفة NumPy أفقيًا
تكديس تسلسل مصفوفة NumPy عموديًا
الانضمام إلى NumPy Array
الجمع بين مصفوفة NumPy أحادية وثنائية الأبعاد
مصفوفتان متسلسلة - np.ma.concatenate ()
فهرس مصفوفة مجمعة بالفهرس
تقسيم المصفوفات في NumPy
قارن بين مصفوفتي NumPy
أوجد اتحاد صفيفتي NumPy
ابحث عن صفوف فريدة في مصفوفة NumPy
احصل على القيم الفريدة من المصفوفة
تقليم الأصفار البادئة و / أو اللاحقة من صفيف أحادي الأبعاد
المصفوفة في NumPy
معالجة المصفوفة في بايثون
عمليات المصفوفة المعقدة | دالة () فارغة
عمليات المصفوفة المعقدة | الأصفار ()
عمليات المصفوفة المعقدة | واحد () وظيفة
عمليات المصفوفة المعقدة | وظيفة العين ()
عمليات المصفوفة المعقدة | تطابق وظيفي
جمع وطرح المصفوفات في بايثون
ضرب المصفوفة في NumPy
حاصل الضرب النقطي لمصفوفتين
نومبي | ناقلات الضرب
كيف تحسب حاصل الضرب القياسي لمتجهين في بايثون؟
ضرب مصفوفتين في سطر واحد باستخدام Numpy في Python
احصل على قيم eigen لمصفوفة
احسب محدد مصفوفة باستخدام NumPy
أوجد مدور المصفوفة
أوجد تباين المصفوفة
احسب معكوس المصفوفة باستخدام NumPy
العمليات على NumPy Array
نومبي - العمليات الثنائية
Numpy - دالة رياضية
Numpy - عمليات السلسلة
إعادة تشكيل مصفوفة NumPy
إعادة تشكيل صفيف NumPy
غيّر حجم شكل المصفوفة المعطاة
أعد تشكيل شكل المصفوفة المعطاة
احصل على شكل مصفوفة NumPy
قم بتغيير أبعاد صفيف NumPy
تغيير شكل وحجم المصفوفة في المكان
قم بتسوية مصفوفة في بايثون باستخدام NumPy
تسطيح مصفوفة - matrix.ravel ()
انقل محاور المصفوفة إلى مواضع جديدة
تبادل محورين من المصفوفة
تبديل المحاور بمصفوفة
قسّم مصفوفة إلى مصفوفات فرعية متعددة عموديًا
قسّم مصفوفة إلى مصفوفات فرعية متعددة أفقيًا
أعط شكلاً جديدًا للمصفوفة المقنعة دون تغيير بياناتها
اضغط على حجم المصفوفة
فهرسة مصفوفة NumPy
التقطيع الأساسي والفهرسة المتقدمة في NumPy Python
احصل على شرائح محددة من مصفوفة على طول المحور المذكور
الوصول إلى البيانات عبر مصفوفات ذات أبعاد متعددة في Python Numpy
كيفية الوصول إلى صفوف مختلفة من مصفوفة NumPy متعددة الأبعاد؟
احصل على مؤشرات المثلث السفلي لمصفوفة (n ، m)
العمليات الحسابية على NumPy Array
البث مع NumPy Arrays
تقدير المتغير
Python: العمليات على مصفوفات Numpy
كيف تستخدم وظيفة NumPy sum؟
قسّم عنصر مصفوفة NumPy حسب الحكمة
لحساب الناتج الداخلي لمصفوفتين
الانحراف المطلق والمتوسط ​​المطلق للانحراف باستخدام NumPy
أوجد الانحراف المعياري مصفوفة
احسب GCD لصفيف NumPy
الجبر الخطي في NumPy Array
نومبي | الجبر الخطي
احصل على معامل QR لصفيف NumPy محدد
كيفية الحصول على حجم المتجه في NumPy؟
احسب قيم eigenvalues ​​والمتجهات الذاتية الصحيحة لمصفوفة مربعة معينة باستخدام NumPy؟
NumPy والبيانات العشوائية
أخذ عينات عشوائي في numpy | ranf () وظيفة
أخذ عينات عشوائي في numpy | دالة عشوائية ()
أخذ عينات عشوائي في numpy | دالة random_sample ()
أخذ عينات عشوائي في numpy | عينة () وظيفة
أخذ عينات عشوائي في numpy | دالة عشوائية ()
أخذ عينات عشوائي في numpy | وظيفة randint ()
الحصول على عناصر عشوائية من NumPy - random.choice ()
كيف تختار عناصر من القائمة باحتمالات مختلفة باستخدام NumPy؟
كيف تحصل على خيار عشوائي مرجح في بايثون؟
كيفية الحصول على تحديد المواقع العشوائية لقيم عددية مختلفة؟
احصل على عناصر عشوائية من التوزيع الهندسي
احصل على عينات عشوائية من سلسلة من التقليب
الفرز والبحث في NumPy Array
البحث في مصفوفة NumPy
كيفية فرز Numpy Array
Numpy - الفرز والبحث والعد
الاختلافات في تقنيات الفرز المختلفة في بايثون
فرز مجموعة معقدة
احصل على الحد الأدنى من قيمة مجموعة مقنعة
رتب القيم في مصفوفة
افرز العناصر في المصفوفة المحددة التي لها بُعد واحد أو أكثر
وظائف عالمية
نومبي ufunc | وظائف عالمية
قم بإنشاء الوظيفة العامة الخاصة بك في NumPy
العمل مع الصور
قم بإنشاء صورة بيضاء باستخدام NumPy في Python
تحويل مصفوفة NumPy إلى صورة
كيفية تحويل الصور إلى مجموعة NumPy؟
هل تريد تحويل صورة إلى مجموعة NumPy وحفظها في ملف CSV باستخدام Python؟
المشاريع والتطبيقات مع NumPy
طباعة نمط رقعة الشطرنج لـ nxn باستخدام numpy
تنفيذ الشبكة العصبية من الصفر باستخدام NumPy
تحليل سعر بيع السيارات المستعملة باستخدام لغة بايثون

<<<<<<<<<<<<<<<<<<<
بيثون نومبي
تاريخ التحديث الأخير: 15 أكتوبر 2018
Numpy عبارة عن حزمة معالجة مصفوفة للأغراض العامة. يوفر كائن مصفوفة متعدد الأبعاد عالي الأداء وأدوات للعمل مع هذه المصفوفات. إنها الحزمة الأساسية للحوسبة العلمية باستخدام بايثون.
إلى جانب الاستخدامات العلمية الواضحة ، يمكن أيضًا استخدام Numpy كحاوية فعالة متعددة الأبعاد للبيانات العامة.

المصفوفات في نومبي
المصفوفة في Numpy هي جدول عناصر (عادةً أرقام) ، جميعها من نفس النوع ، مفهرسة بمجموعة من الأعداد الصحيحة الموجبة. في Numpy ، يسمى عدد أبعاد المصفوفة رتبة المصفوفة. تُعرف مجموعة الأعداد الصحيحة التي تعطي حجم المصفوفة على طول كل بُعد باسم شكل المصفوفة. يُطلق على فئة المصفوفة في Numpy اسم ndarray . يتم الوصول إلى العناصر في مصفوفات Numpy باستخدام أقواس مربعة ويمكن تهيئتها باستخدام قوائم Python المتداخلة.

يمكن إنشاء
مصفوفات Numpy Array في Numpy بعدة طرق ، مع عدد مختلف من الرتب ، وتحديد حجم المصفوفة. يمكن أيضًا إنشاء المصفوفات باستخدام أنواع بيانات مختلفة مثل القوائم ، المجموعات ، إلخ. يتم استنتاج نوع المصفوفة الناتجة من نوع العناصر في التسلسلات.
ملاحظة: يمكن تحديد نوع المصفوفة بوضوح أثناء تكوين المصفوفة.

# Python program for
# Creation of Arrays
import numpy as np
 
# Creating a rank 1 Array
arr = np.array([1, 2, 3])
print("Array with Rank 1: \n",arr)
 
# Creating a rank 2 Array
arr = np.array([[1, 2, 3],
                [4, 5, 6]])
print("Array with Rank 2: \n", arr)
 
# Creating an array from tuple
arr = np.array((1, 3, 2))
print("\nArray created using "
      "passed tuple:\n", arr)
تشغيل على IDE
انتاج:

مصفوفة بالرتبة 1:
 [1 2 3]
مصفوفة من المرتبة 2:
 [[1 2 3]
 [4 5 6]]

تم إنشاء المصفوفة باستخدام tuple الذي تم تمريره:
 [1 3 2]
 
الوصول إلى فهرس المصفوفة
في مصفوفة صغيرة ، يمكن إجراء فهرسة أو الوصول إلى فهرس المصفوفة بعدة طرق. لطباعة نطاق من مصفوفة ، يتم إجراء التقطيع. تقسيم المصفوفة إلى شرائح تحدد نطاقًا في مصفوفة جديدة تُستخدم لطباعة نطاق من العناصر من المصفوفة الأصلية. نظرًا لأن المصفوفة المقطعة تحتوي على مجموعة من عناصر المصفوفة الأصلية ، فإن تعديل المحتوى بمساعدة المصفوفة المقطعة يؤدي إلى تعديل محتوى المصفوفة الأصلي.

# Python program to demonstrate
# indexing in numpy array
import numpy as np
 
# Initial Array
arr = np.array([[-1, 2, 0, 4],
                [4, -0.5, 6, 0],
                [2.6, 0, 7, 8],
                [3, -7, 4, 2.0]])
print("Initial Array: ")
print(arr)
 
# Printing a range of Array
# with the use of slicing method
sliced_arr = arr[:2, ::2]
print ("Array with first 2 rows and"
    " alternate columns(0 and 2):\n", sliced_arr)
 
# Printing elements at
# specific Indices
Index_arr = arr[[1, 1, 0, 3], 
                [3, 2, 1, 0]]
print ("\nElements at indices (1, 3), "
    "(1, 2), (0, 1), (3, 0):\n", Index_arr)
تشغيل على IDE
انتاج:

المصفوفة الأولية:
[[-1. 2. 0. 4.]
 [4. -0.5 6. 0.]
 [2.6 0. 7. 8.]
 [3. -7. 4. 2.]]
صفيف يحتوي على أول صفين وأعمدة بديلة (0 و 2):
 [[-1. 0.]
 [4. 6.]]

العناصر في المؤشرات (1 ، 3) ، (1 ، 2) ، (0 ، 1) ، (3 ، 0):
 [0. 54. 2. 3.]

 
عمليات المصفوفة الأساسية
في الصفيف numpy ، تسمح المصفوفات بنطاق واسع من العمليات التي يمكن إجراؤها على مصفوفة معينة أو مجموعة من المصفوفات. تتضمن هذه العملية بعض العمليات الحسابية الأساسية بالإضافة إلى العمليات الأحادية والثنائية.

# Python program to demonstrate
# basic operations on single array
import numpy as np
 
# Defining Array 1
a = np.array([[1, 2],
              [3, 4]])
 
# Defining Array 2
b = np.array([[4, 3],
              [2, 1]])
               
# Adding 1 to every element
print ("Adding 1 to every element:", a + 1)
 
# Subtracting 2 from each element
print ("\nSubtracting 2 from each element:", b - 2)
 
# sum of array elements
# Performing Unary operations
print ("\nSum of all array "
       "elements: ", a.sum())
 
# Adding two arrays
# Performing Binary operations
print ("\nArray sum:\n", a + b)
تشغيل على IDE
انتاج:

إضافة 1 لكل عنصر:
 [[2 3]
 [4 5]]

طرح 2 من كل عنصر:
 [[2 1]
 [0 -1]]

مجموع كل عناصر المصفوفة: 10

مجموع المصفوفة:
 [[5 5]
 [5 5]]
 
المزيد عن Numpy Arrays

عمليات الصفيف الأساسية في Numpy
عمليات الصفيف المتقدمة في Numpy
التقطيع الأساسي والفهرسة المتقدمة في NumPy Python
أنواع البيانات في Numpy
كل مصفوفة Numpy هي جدول عناصر (أرقام عادةً) ، جميعها من نفس النوع ، مفهرسة بواسطة مجموعة من الأعداد الصحيحة الموجبة. كل ndarray له نوع بيانات مرتبط (نوع dtype). يوفر كائن نوع البيانات (نوع البيانات) هذا معلومات حول تخطيط المصفوفة. يتم تخزين قيم ndarray في مخزن مؤقت يمكن اعتباره كتلة متجاورة من بايتات الذاكرة والتي يمكن تفسيرها بواسطة كائن dtype. يوفر Numpy مجموعة كبيرة من أنواع البيانات الرقمية التي يمكن استخدامها لبناء المصفوفات. في وقت إنشاء المصفوفة ، يحاول Numpy تخمين نوع البيانات ، لكن الوظائف التي تنشئ المصفوفات عادةً ما تتضمن أيضًا وسيطة اختيارية لتحديد نوع البيانات بشكل صريح.

إنشاء كائن نوع بيانات
في Numpy ، لا يلزم تحديد أنواع بيانات المصفوفات ما لم يكن نوع بيانات محددًا مطلوبًا. يحاول Numpy تخمين نوع بيانات المصفوفات التي لم يتم تحديدها مسبقًا في دالة المُنشئ.

# Python Program to create
# a data type object
import numpy as np
 
# Integer datatype
# guessed by Numpy
x = np.array([1, 2])  
print("Integer Datatype: ")
print(x.dtype)         
 
# Float datatype
# guessed by Numpy
x = np.array([1.0, 2.0]) 
print("\nFloat Datatype: ")
print(x.dtype)  
 
# Forced Datatype
x = np.array([1, 2], dtype = np.int64)   
print("\nForcing a Datatype: ")
print(x.dtype)
تشغيل على IDE
انتاج:

نوع بيانات صحيح:
int64

نوع بيانات تعويم:
تعويم 64

فرض نوع البيانات:
int64
 
العمليات الحسابية على مصفوفة
نوع البيانات في مصفوفات Numpy ، يتم تنفيذ العمليات الحسابية الأساسية على مستوى العناصر على المصفوفة. يتم تطبيق هذه العمليات كحمل زائد للمشغل وكوظائف. يتم توفير العديد من الوظائف المفيدة في Numpy لإجراء العمليات الحسابية على المصفوفات مثل sum : لإضافة عناصر Array ، T : لتغيير العناصر ، إلخ.

# Python Program to create
# a data type object
import numpy as np
 
# First Array
arr1 = np.array([[4, 7], [2, 6]], 
                 dtype = np.float64)
                  
# Second Array
arr2 = np.array([[3, 6], [2, 8]], 
                 dtype = np.float64) 
 
# Addition of two Arrays
Sum = np.add(arr1, arr2)
print("Addition of Two Arrays: ")
print(Sum)
 
# Addition of all Array elements
# using predefined sum method
Sum1 = np.sum(arr1)
print("\nAddition of Array elements: ")
print(Sum1)
 
# Square root of Array
Sqrt = np.sqrt(arr1)
print("\nSquare root of Array1 elements: ")
print(Sqrt)
 
# Transpose of Array
# using In-built function 'T'
Trans_arr = arr1.T
print("\nTranspose of Array: ")
print(Trans_arr)
تشغيل على IDE
انتاج:

إضافة صفيفين:
[[7. 13.]
 [4. 14.]]

إضافة عناصر المصفوفة:
19.0

الجذر التربيعي لعناصر Array1:
[[2. 2.64575131]
 [1.41421356 2.44948974]]

تبديل الصفيف:
[[4. 2.]
 [7. 6.]]
 
المزيد عن نوع البيانات Numpy

نوع البيانات Object (dtype) في NumPy
الطرق في نومبي
الكل()
أي()
يأخذ()
وضع()
application_along_axis ()
application_over_axes ()
أرجمين ()
أرجماكس ()
نانارجمين ()
نانارجماكس ()
أماكس ()
امين ()
إدراج()
حذف()
ألحق()
حول()
يواجه()
fliplr ()
فليبود ()
تريو ()
تريل ()
ثلاثي ()
فارغة()
فارغ_مثل ()
الأصفار ()
أصفار_مثل ()
واحد ()
واحد_لايك ()
full_like ()
دياج ()
دياجلات ()
مؤشرات_مخطط ()
أسماتريكس ()
بمات ()
عين()
تدحرج()
هوية()
غريب ()
مكان()
استخراج()
ضغط()
روت 90 ()
بلاط ()
إعادة تشكيل ()
تشوش()
isinf ()
isrealobj ()
إيسكالار ()
isneginf ()
isposinf ()
iscomplex ()
إسنان ()
iscomplexobj ()
انه حقيقي()
غير محدود ()
isfortran ()
إكسب ()
إكسب 2 ()
يصلح()
وتر ()
مطلق()
سقف()
الأرض()
درجات()
راديان()
npv ()
fv ()
الكهروضوئية ()
قوة()
float_power ()
سجل()
تسجيل 1 ()
log2 ()
log10 ()
نقطة()
فدوت ()
trunc ()
يقسم()
تقسيم_الطابق ()
تقسيم صحيح ()
العلامة العشوائية ()
عشوائي.randn ()
ndarray.flat ()
expm1 ()
بينكونت ()
طبع ()
مساو()
ليس متساوي()
أقل()
أقل_مساواة ()
أكبر()
أكبر_متساوية ()
همز()
ميدان()
cbrt ()
منطقي أو ()
منطقي و ()
logical_not ()
logical_xor ()
array_equal ()
array_equiv ()
الخطيئة ()
كوس ()
تان ()
سينه ()
ضرب بالعصا()
تانه ()
أركسين ()
arccos ()
أركتان ()
arctan2 ()

المقالات الأخيرة على Numpy

برامج Numpy

بايثون | تحقق مما إذا كانت القائمة فارغة أم لا
بايثون | احصل على قيم فريدة من القائمة
بايثون | اضرب كل الأرقام الموجودة في القائمة (3 طرق مختلفة)
قلب مصفوفة في سطر واحد في بايثون
ضرب مصفوفتين في سطر واحد باستخدام Numpy في Python
برنامج Python لطباعة نمط رقعة الشطرنج من nxn باستخدام numpy
الرسم البياني في بايثون | المجموعة 1 ، المجموعة 2 ، المجموعة 3
مقالات مفيدة Numpy

معالجة المصفوفة في بايثون
التقطيع الأساسي والفهرسة المتقدمة في NumPy Python
الاختلافات بين Flatten () و Ravel ()
rand مقابل عادي في Numpy.random في Python
<<<<<<<<<<<<<<<<<<<
بيثون نومبي
تاريخ التحديث الأخير: 15 أكتوبر 2018
Numpy عبارة عن حزمة معالجة مصفوفة للأغراض العامة. يوفر كائن مصفوفة متعدد الأبعاد عالي الأداء وأدوات للعمل مع هذه المصفوفات. إنها الحزمة الأساسية للحوسبة العلمية باستخدام بايثون.
إلى جانب الاستخدامات العلمية الواضحة ، يمكن أيضًا استخدام Numpy كحاوية فعالة متعددة الأبعاد للبيانات العامة.

المصفوفات في نومبي
المصفوفة في Numpy هي جدول عناصر (عادةً أرقام) ، جميعها من نفس النوع ، مفهرسة بمجموعة من الأعداد الصحيحة الموجبة. في Numpy ، يسمى عدد أبعاد المصفوفة رتبة المصفوفة. تُعرف مجموعة الأعداد الصحيحة التي تعطي حجم المصفوفة على طول كل بُعد باسم شكل المصفوفة. يُطلق على فئة المصفوفة في Numpy اسم ndarray . يتم الوصول إلى العناصر في مصفوفات Numpy باستخدام أقواس مربعة ويمكن تهيئتها باستخدام قوائم Python المتداخلة.

يمكن إنشاء
مصفوفات Numpy Array في Numpy بعدة طرق ، مع عدد مختلف من الرتب ، وتحديد حجم المصفوفة. يمكن أيضًا إنشاء المصفوفات باستخدام أنواع بيانات مختلفة مثل القوائم ، المجموعات ، إلخ. يتم استنتاج نوع المصفوفة الناتجة من نوع العناصر في التسلسلات.
ملاحظة: يمكن تحديد نوع المصفوفة بوضوح أثناء تكوين المصفوفة.

# Python program for
# Creation of Arrays
import numpy as np
 
# Creating a rank 1 Array
arr = np.array([1, 2, 3])
print("Array with Rank 1: \n",arr)
 
# Creating a rank 2 Array
arr = np.array([[1, 2, 3],
                [4, 5, 6]])
print("Array with Rank 2: \n", arr)
 
# Creating an array from tuple
arr = np.array((1, 3, 2))
print("\nArray created using "
      "passed tuple:\n", arr)
تشغيل على IDE
انتاج:

مصفوفة بالرتبة 1:
 [1 2 3]
مصفوفة من المرتبة 2:
 [[1 2 3]
 [4 5 6]]

تم إنشاء المصفوفة باستخدام tuple الذي تم تمريره:
 [1 3 2]
 
الوصول إلى فهرس المصفوفة
في مصفوفة صغيرة ، يمكن إجراء فهرسة أو الوصول إلى فهرس المصفوفة بعدة طرق. لطباعة نطاق من مصفوفة ، يتم إجراء التقطيع. تقسيم المصفوفة إلى شرائح تحدد نطاقًا في مصفوفة جديدة تُستخدم لطباعة نطاق من العناصر من المصفوفة الأصلية. نظرًا لأن المصفوفة المقطعة تحتوي على مجموعة من عناصر المصفوفة الأصلية ، فإن تعديل المحتوى بمساعدة المصفوفة المقطعة يؤدي إلى تعديل محتوى المصفوفة الأصلي.

# Python program to demonstrate
# indexing in numpy array
import numpy as np
 
# Initial Array
arr = np.array([[-1, 2, 0, 4],
                [4, -0.5, 6, 0],
                [2.6, 0, 7, 8],
                [3, -7, 4, 2.0]])
print("Initial Array: ")
print(arr)
 
# Printing a range of Array
# with the use of slicing method
sliced_arr = arr[:2, ::2]
print ("Array with first 2 rows and"
    " alternate columns(0 and 2):\n", sliced_arr)
 
# Printing elements at
# specific Indices
Index_arr = arr[[1, 1, 0, 3], 
                [3, 2, 1, 0]]
print ("\nElements at indices (1, 3), "
    "(1, 2), (0, 1), (3, 0):\n", Index_arr)
تشغيل على IDE
انتاج:

المصفوفة الأولية:
[[-1. 2. 0. 4.]
 [4. -0.5 6. 0.]
 [2.6 0. 7. 8.]
 [3. -7. 4. 2.]]
صفيف يحتوي على أول صفين وأعمدة بديلة (0 و 2):
 [[-1. 0.]
 [4. 6.]]

العناصر في المؤشرات (1 ، 3) ، (1 ، 2) ، (0 ، 1) ، (3 ، 0):
 [0. 54. 2. 3.]

 
عمليات المصفوفة الأساسية
في الصفيف numpy ، تسمح المصفوفات بنطاق واسع من العمليات التي يمكن إجراؤها على مصفوفة معينة أو مجموعة من المصفوفات. تتضمن هذه العملية بعض العمليات الحسابية الأساسية بالإضافة إلى العمليات الأحادية والثنائية.

# Python program to demonstrate
# basic operations on single array
import numpy as np
 
# Defining Array 1
a = np.array([[1, 2],
              [3, 4]])
 
# Defining Array 2
b = np.array([[4, 3],
              [2, 1]])
               
# Adding 1 to every element
print ("Adding 1 to every element:", a + 1)
 
# Subtracting 2 from each element
print ("\nSubtracting 2 from each element:", b - 2)
 
# sum of array elements
# Performing Unary operations
print ("\nSum of all array "
       "elements: ", a.sum())
 
# Adding two arrays
# Performing Binary operations
print ("\nArray sum:\n", a + b)
تشغيل على IDE
انتاج:

إضافة 1 لكل عنصر:
 [[2 3]
 [4 5]]

طرح 2 من كل عنصر:
 [[2 1]
 [0 -1]]

مجموع كل عناصر المصفوفة: 10

مجموع المصفوفة:
 [[5 5]
 [5 5]]
 
المزيد عن Numpy Arrays

عمليات الصفيف الأساسية في Numpy
عمليات الصفيف المتقدمة في Numpy
التقطيع الأساسي والفهرسة المتقدمة في NumPy Python
أنواع البيانات في Numpy
كل مصفوفة Numpy هي جدول عناصر (أرقام عادةً) ، جميعها من نفس النوع ، مفهرسة بواسطة مجموعة من الأعداد الصحيحة الموجبة. كل ndarray له نوع بيانات مرتبط (نوع dtype). يوفر كائن نوع البيانات (نوع البيانات) هذا معلومات حول تخطيط المصفوفة. يتم تخزين قيم ndarray في مخزن مؤقت يمكن اعتباره كتلة متجاورة من بايتات الذاكرة والتي يمكن تفسيرها بواسطة كائن dtype. يوفر Numpy مجموعة كبيرة من أنواع البيانات الرقمية التي يمكن استخدامها لبناء المصفوفات. في وقت إنشاء المصفوفة ، يحاول Numpy تخمين نوع البيانات ، لكن الوظائف التي تنشئ المصفوفات عادةً ما تتضمن أيضًا وسيطة اختيارية لتحديد نوع البيانات بشكل صريح.

إنشاء كائن نوع بيانات
في Numpy ، لا يلزم تحديد أنواع بيانات المصفوفات ما لم يكن نوع بيانات محددًا مطلوبًا. يحاول Numpy تخمين نوع بيانات المصفوفات التي لم يتم تحديدها مسبقًا في دالة المُنشئ.

# Python Program to create
# a data type object
import numpy as np
 
# Integer datatype
# guessed by Numpy
x = np.array([1, 2])  
print("Integer Datatype: ")
print(x.dtype)         
 
# Float datatype
# guessed by Numpy
x = np.array([1.0, 2.0]) 
print("\nFloat Datatype: ")
print(x.dtype)  
 
# Forced Datatype
x = np.array([1, 2], dtype = np.int64)   
print("\nForcing a Datatype: ")
print(x.dtype)
تشغيل على IDE
انتاج:

نوع بيانات صحيح:
int64

نوع بيانات تعويم:
تعويم 64

فرض نوع البيانات:
int64
 
العمليات الحسابية على مصفوفة
نوع البيانات في مصفوفات Numpy ، يتم تنفيذ العمليات الحسابية الأساسية على مستوى العناصر على المصفوفة. يتم تطبيق هذه العمليات كحمل زائد للمشغل وكوظائف. يتم توفير العديد من الوظائف المفيدة في Numpy لإجراء العمليات الحسابية على المصفوفات مثل sum : لإضافة عناصر Array ، T : لتغيير العناصر ، إلخ.

# Python Program to create
# a data type object
import numpy as np
 
# First Array
arr1 = np.array([[4, 7], [2, 6]], 
                 dtype = np.float64)
                  
# Second Array
arr2 = np.array([[3, 6], [2, 8]], 
                 dtype = np.float64) 
 
# Addition of two Arrays
Sum = np.add(arr1, arr2)
print("Addition of Two Arrays: ")
print(Sum)
 
# Addition of all Array elements
# using predefined sum method
Sum1 = np.sum(arr1)
print("\nAddition of Array elements: ")
print(Sum1)
 
# Square root of Array
Sqrt = np.sqrt(arr1)
print("\nSquare root of Array1 elements: ")
print(Sqrt)
 
# Transpose of Array
# using In-built function 'T'
Trans_arr = arr1.T
print("\nTranspose of Array: ")
print(Trans_arr)
تشغيل على IDE
انتاج:

إضافة صفيفين:
[[7. 13.]
 [4. 14.]]

إضافة عناصر المصفوفة:
19.0

الجذر التربيعي لعناصر Array1:
[[2. 2.64575131]
 [1.41421356 2.44948974]]

تبديل الصفيف:
[[4. 2.]
 [7. 6.]]
 
المزيد عن نوع البيانات Numpy

نوع البيانات Object (dtype) في NumPy
الطرق في نومبي
الكل()
أي()
يأخذ()
وضع()
application_along_axis ()
application_over_axes ()
أرجمين ()
أرجماكس ()
نانارجمين ()
نانارجماكس ()
أماكس ()
امين ()
إدراج()
حذف()
ألحق()
حول()
يواجه()
fliplr ()
فليبود ()
تريو ()
تريل ()
ثلاثي ()
فارغة()
فارغ_مثل ()
الأصفار ()
أصفار_مثل ()
واحد ()
واحد_لايك ()
full_like ()
دياج ()
دياجلات ()
مؤشرات_مخطط ()
أسماتريكس ()
بمات ()
عين()
تدحرج()
هوية()
غريب ()
مكان()
استخراج()
ضغط()
روت 90 ()
بلاط ()
إعادة تشكيل ()
تشوش()
isinf ()
isrealobj ()
إيسكالار ()
isneginf ()
isposinf ()
iscomplex ()
إسنان ()
iscomplexobj ()
انه حقيقي()
غير محدود ()
isfortran ()
إكسب ()
إكسب 2 ()
يصلح()
وتر ()
مطلق()
سقف()
الأرض()
درجات()
راديان()
npv ()
fv ()
الكهروضوئية ()
قوة()
float_power ()
سجل()
تسجيل 1 ()
log2 ()
log10 ()
نقطة()
فدوت ()
trunc ()
يقسم()
تقسيم_الطابق ()
تقسيم صحيح ()
العلامة العشوائية ()
عشوائي.randn ()
ndarray.flat ()
expm1 ()
بينكونت ()
طبع ()
مساو()
ليس متساوي()
أقل()
أقل_مساواة ()
أكبر()
أكبر_متساوية ()
همز()
ميدان()
cbrt ()
منطقي أو ()
منطقي و ()
logical_not ()
logical_xor ()
array_equal ()
array_equiv ()
الخطيئة ()
كوس ()
تان ()
سينه ()
ضرب بالعصا()
تانه ()
أركسين ()
arccos ()
أركتان ()
arctan2 ()

المقالات الأخيرة على Numpy

برامج Numpy

بايثون | تحقق مما إذا كانت القائمة فارغة أم لا
بايثون | احصل على قيم فريدة من القائمة
بايثون | اضرب كل الأرقام الموجودة في القائمة (3 طرق مختلفة)
قلب مصفوفة في سطر واحد في بايثون
ضرب مصفوفتين في سطر واحد باستخدام Numpy في Python
برنامج Python لطباعة نمط رقعة الشطرنج من nxn باستخدام numpy
الرسم البياني في بايثون | المجموعة 1 ، المجموعة 2 ، المجموعة 3
مقالات مفيدة Numpy

معالجة المصفوفة في بايثون
التقطيع الأساسي والفهرسة المتقدمة في NumPy Python
الاختلافات بين Flatten () و Ravel ()
rand مقابل عادي في Numpy.random في Python
<<<<<<<<<<<<<<<<<<<
نومبي | إنشاء المصفوفة
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
إنشاء المصفوفات باستخدام List: تُستخدم المصفوفات لتخزين قيم متعددة في متغير واحد. لا يحتوي Python على دعم مدمج للمصفوفات ، ولكن يمكن استخدام قوائم Python بدلاً من ذلك.
مثال :

arr = [1، 2، 3، 4، 5]
arr1 = ["geeks"، "for"، "geeks"]
# Python program to create 
# an array
 
# Creating an array using list
    arr=[1, 2, 3, 4, 5]
    for i in arr:
        print(i)
تشغيل على IDE
انتاج:

1
2
3
4
5
 
إنشاء الصفيف باستخدام وظائف الصفيف: يتم استخدام وظيفة
المصفوفة (نوع البيانات ، قائمة القيم) لإنشاء مصفوفة بنوع البيانات وقائمة القيم المحددة في وسيطاتها.
مثال :

# Python code to demonstrate the working of 
# array()
  
# importing "array" for array operations
import array
  
# initializing array with array values
# initializes array with signed integers
arr = array.array('i', [1, 2, 3]) 
 
# printing original array
print ("The new created array is : ",end="")
for i in range (0,3):
    print (arr[i], end=" ")
 
print ("\r")
تشغيل على IDE
انتاج:

المصفوفة الجديدة التي تم إنشاؤها هي: 1 2 3 1 5
 
إنشاء المصفوفة باستخدام طرق numpy:
يوفر NumPy العديد من الوظائف لإنشاء مصفوفات بمحتوى عنصر نائب أولي. هذه تقلل من ضرورة نمو المصفوفات ، وهي عملية مكلفة. على سبيل المثال: np.zeros و np.empty وما إلى ذلك.

numpy.empty (shape، dtype = float، order = 'C') : إرجاع مصفوفة جديدة من الشكل والنوع المحددين ، بقيم عشوائية.

# Python Programming illustrating
# numpy.empty method
 
import numpy as geek
 
b = geek.empty(2, dtype = int)
print("Matrix b : \n", b)
 
a = geek.empty([2, 2], dtype = int)
print("\nMatrix a : \n", a)
 
c = geek.empty([3, 3])
print("\nMatrix c : \n", c)
تشغيل على IDE
انتاج :

مصفوفة ب:
 [0 1079574528]

المصفوفة أ:
 [[0]
 [0 0]]

المصفوفة أ:
 [[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
numpy.zeros (الشكل ، dtype = بلا ، الترتيب = 'C') : إرجاع مصفوفة جديدة من الشكل والنوع المحددين ، مع الأصفار.

# Python Program illustrating
# numpy.zeros method
 
import numpy as geek
 
b = geek.zeros(2, dtype = int)
print("Matrix b : \n", b)
 
a = geek.zeros([2, 2], dtype = int)
print("\nMatrix a : \n", a)
 
c = geek.zeros([3, 3])
print("\nMatrix c : \n", c)
تشغيل على IDE
انتاج :

مصفوفة ب:
 [0 0]

المصفوفة أ:
 [[0]
 [0 0]]

مصفوفة ج:
 [[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]
 
إعادة تشكيل المصفوفة: يمكننا استخدام reshapeطريقة لإعادة تشكيل المصفوفة. اعتبر مصفوفة ذات شكل (a1، a2، a3،…، aN). يمكننا إعادة تشكيلها وتحويلها إلى مصفوفة أخرى بالشكل (b1 ، b2 ، b3 ، ... ، bM).
الشرط الوحيد المطلوب هو: a1 x a2 x a3… x aN = b1 x b2 x b3… x bM. (على سبيل المثال ، يظل الحجم الأصلي للمصفوفة دون تغيير.)

numpy.reshape (مصفوفة ، شكل ، ترتيب = 'C') : تشكيل مصفوفة بدون تغيير بيانات المصفوفة.

# Python Program illustrating
# numpy.reshape() method
 
import numpy as geek
 
array = geek.arange(8)
print("Original array : \n", array)
 
# shape array with 2 rows and 4 columns
array = geek.arange(8).reshape(2, 4)
print("\narray reshaped with 2 rows and 4 columns : \n", array)
 
# shape array with 2 rows and 4 columns
array = geek.arange(8).reshape(4 ,2)
print("\narray reshaped with 2 rows and 4 columns : \n", array)
 
# Constructs 3D array
array = geek.arange(8).reshape(2, 2, 2)
print("\nOriginal array reshaped to 3D : \n", array)
تشغيل على IDE
انتاج :

المجموعة الأصلية:
 [0 1 2 3 4 5 6 7]

تمت إعادة تشكيل المصفوفة بصفين و 4 أعمدة:
 [[0 1 2 3]
 [4 5 6 7]]

تمت إعادة تشكيل المصفوفة بصفين و 4 أعمدة:
 [[0 1]
 [2 3]
 [4 5]
 [6 7]]

تمت إعادة تشكيل المصفوفة الأصلية إلى 3D:
 [[0 1]
  [2 3]]

 [[4 5]
  [6 7]]
لإنشاء تسلسلات من الأرقام ، يوفر NumPy وظيفة مماثلة للنطاق الذي يُرجع المصفوفات بدلاً من القوائم.
يُرجع arange قيمًا متباعدة بشكل متساوٍ ضمن فترة زمنية معينة. تم تحديد حجم الخطوة .
تقوم linspace بإرجاع قيم متباعدة بشكل متساوٍ خلال فترة زمنية معينة. الأسطوانات لا. يتم إرجاع من العناصر.

arange ([start،] stop [، step،] [، dtype]) : إرجاع مصفوفة بعناصر متباعدة بشكل متساوٍ وفقًا للفاصل الزمني. الفاصل الزمني المذكور نصف مفتوح ، أي [بدء ، إيقاف)

# Python Programming illustrating
# numpy.arange method
 
import numpy as geek
 
print("A\n", geek.arange(4).reshape(2, 2), "\n")
 
print("A\n", geek.arange(4, 10), "\n")
 
print("A\n", geek.arange(4, 20, 3), "\n")
تشغيل على IDE
انتاج :

أ
 [[0 1]
 [2 3]]

أ
 [4 5 6 7 8 9]

أ
 [4 7 10 13 16 19]

numpy.linspace (بدء ، توقف ، عدد = 50 ، نقطة نهاية = صواب ، retstep = خطأ ، نوع dtype = لا شيء) : إرجاع مسافات الأرقام بالتساوي في الفاصل الزمني. مألوف لـ arangeولكن بدلاً من الخطوة يستخدم رقم العينة.

# Python Programming illustrating
# numpy.linspace method
 
import numpy as geek
 
# restep set to True
print("B\n", geek.linspace(2.0, 3.0, num=5, retstep=True), "\n")
 
# To evaluate sin() in long range 
x = geek.linspace(0, 2, 10)
print("A\n", geek.sin(x))
تشغيل على IDE
انتاج :

ب
 (صفيف ([2. ، 2.25 ، 2.5 ، 2.75 ، 3.]) ، 0.25)

أ
 [0. 0.22039774 0.42995636 0.6183698 0.77637192 0.8961922
  0.9719379 0.99988386 0.9786557 0.90929743]
 
مصفوفة مسطحة: يمكننا استخدام طريقة flatten للحصول على نسخة من المصفوفة مطوية في بُعد واحد. يقبل حجة النظام. القيمة الافتراضية هي "C" (لترتيب الصفوف الرئيسية). استخدم "F" لترتيب العمود الرئيسي.

numpy.ndarray.flatten (الترتيب = 'C') : إرجاع نسخة من المصفوفة مطوية في بُعد واحد.

# Python Program illustrating
# numpy.flatten() method
 
import numpy as geek
 
array = geek.array([[1, 2], [3, 4]])
 
# using flatten method
array.flatten()
print(array)
 
#using fatten method 
array.flatten('F')
print(array)
تشغيل على IDE
انتاج :

[1 ، 2 ، 3 ، 4]
[1 ، 3 ، 2 ، 4]
 

طرق إنشاء الصفيف في Numpy
دور	وصف
فارغة()	إرجاع مصفوفة جديدة من الشكل والنوع المحددين ، بدون تهيئة المدخلات
فارغ_مثل ()	قم بإرجاع مصفوفة جديدة بنفس الشكل واكتبها كمصفوفة معينة
عين()	قم بإرجاع مصفوفة ثنائية الأبعاد تحتوي على الآحاد الموجودة على القطر والأصفار في أي مكان آخر.
هوية()	إعادة مصفوفة الهوية
واحد ()	إعادة مصفوفة جديدة من الشكل والنوع المحددين ، مليئة بأخرى
واحد_لايك ()	قم بإرجاع مصفوفة من تلك التي لها نفس الشكل واكتبها كمصفوفة معينة
الأصفار ()	إرجاع مصفوفة جديدة من الشكل والنوع المحددين ، مليئة بالأصفار
أصفار_مثل ()	قم بإرجاع مصفوفة من الأصفار بنفس الشكل واكتب مصفوفة معينة
full_like ()	قم بإرجاع مصفوفة كاملة بنفس الشكل واكتب مصفوفة معينة.
مجموعة مصفوفة()	قم بإنشاء مصفوفة
أساري ()	تحويل المدخلات إلى مصفوفة
أسانياري ()	قم بتحويل المدخلات إلى ndarray ، ولكن قم بتمرير الفئات الفرعية ndarray من خلالها
مصفوفة متقاربة ()	إرجاع مصفوفة متقاربة في الذاكرة (ترتيب C)
أسماتريكس ()	فسر المدخلات على أنها مصفوفة
ينسخ()	إرجاع نسخة مصفوفة من الكائن المحدد
frombuffer ()	تفسير المخزن المؤقت على أنه مصفوفة ذات بعد واحد
من - الملف()	بناء مصفوفة من البيانات في ملف نصي أو ثنائي
من الوظيفة ()	أنشئ مصفوفة بتنفيذ دالة على كل إحداثي
فرونيتر ()	قم بإنشاء صفيف جديد أحادي البعد من كائن قابل للتكرار
fromstring ()	مصفوفة 1-D جديدة تمت تهيئتها من بيانات نصية في سلسلة
تحميل ()	تحميل البيانات من ملف نصي
غريب ()	إرجاع القيم المتباعدة بشكل متساو في فترة زمنية معينة
لينسبيس ()	إرجاع الأرقام المتباعدة بشكل متساو خلال فترة زمنية محددة
logspace ()	إرجاع الأرقام متباعدة بشكل متساوٍ على مقياس لوغاريتمي
الفضاء الجغرافي ()	إرجاع الأرقام متباعدة بشكل متساوٍ على مقياس لوغاريتمي (تقدم هندسي)
شبكة ()	إرجاع مصفوفات الإحداثيات من متجهات الإحداثيات
مجريد ()	مثيل nd_grid الذي يقوم بإرجاع "meshgrid" كثيف متعدد الأبعاد
ogrid ()	مثيل nd_grid الذي يقوم بإرجاع "meshgrid مفتوح متعدد الأبعاد
دياج ()	استخرج صفيفًا قطريًا أو أنشئ صفيفًا قطريًا
دياجلات ()	قم بإنشاء مصفوفة ثنائية الأبعاد بإدخال مُسطَّح كقطري
ثلاثي ()	مصفوفة بها آحاد عند وتحت القطر المحدد والأصفار في مكان آخر
تريل ()	المثلث السفلي من المصفوفة
تريو ()	المثلث العلوي من المصفوفة
فاندر ()	إنشاء مصفوفة Vandermonde
حصيرة()	فسر المدخلات على أنها مصفوفة
بمات ()	قم ببناء كائن مصفوفة من سلسلة أو تسلسل متداخل أو مصفوفة
<<<<<<<<<<<<<<<<<<<
نومبي | الفهرسة
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
NumPy أو Numeric Python عبارة عن حزمة للحساب على مصفوفات متجانسة ذات أبعاد n. في الأبعاد الخرسانية تسمى المحاور.

لماذا نحتاج NumPy؟

يطرح سؤال لماذا نحتاج إلى NumPy عندما تكون قوائم Python موجودة بالفعل. الجواب هو أننا لا نستطيع إجراء عمليات على جميع عناصر قائمتين مباشرة. على سبيل المثال ، لا يمكننا ضرب قائمتين مباشرة ، فسيتعين علينا القيام بذلك من حيث العناصر. هذا هو المكان الذي يلعب فيه دور NumPy.

مثال 1:

# Python program to demonstrate a need of NumPy
 
list1 = [1, 2, 3, 4 ,5, 6]
list2 = [10, 9, 8, 7, 6, 5]
 
# Multiplying both lists directly would give an error.
print(list1*list2)
تشغيل على IDE
انتاج :

TypeError: لا يمكن مضاعفة التسلسل في non-int من النوع "list"
حيث يمكن القيام بذلك بسهولة باستخدام مصفوفات NumPy.

المثال الثاني:

# Python program to demonstrate the use of NumPy arrays
import numpy as np
 
list1 = [1, 2, 3, 4, 5, 6]
list2 = [10, 9, 8, 7, 6, 5]
 
# Convert list1 into a NumPy array
a1 = np.array(list1)
 
# Convert list2 into a NumPy array
a2 = np.array(list2)
 
print(a1*a2)
تشغيل على IDE
انتاج :

مجموعة ([10 ، 18 ، 24 ، 28 ، 30 ، 30])
حزمة Numpy من python لديها قوة كبيرة في الفهرسة بطرق مختلفة.

الفهرسة باستخدام مصفوفات الفهرس

يمكن إجراء الفهرسة في numpy باستخدام مصفوفة كفهرس. في حالة الشرائح ، يتم إرجاع عرض أو نسخة ضحلة من المصفوفة ولكن في مصفوفة الفهرس يتم إرجاع نسخة من المصفوفة الأصلية. يمكن فهرسة المصفوفات Numpy بمصفوفات أخرى أو أي تسلسل آخر باستثناء المجموعات. تتم فهرسة العنصر الأخير بمقدار -1 ثانية أخيرًا بمقدار -2 وهكذا.

مثال 1:

# Python program to demonstrate 
# the use of index arrays.
import numpy as np
 
# Create a sequence of integers from
# 10 to 1 with a step of -2
a = np.arange(10, 1, -2) 
print("\n A sequential array with a negative step: \n",a)
 
# Indexes are specified inside the np.array method.
newarr = a[np.array([3, 1, 2 ])]
print("\n Elements at these indices are:\n",newarr)
تشغيل على IDE
انتاج :

مصفوفة متسلسلة بخطوة سالبة:
[10 8 6 4 2]

العناصر في هذه المؤشرات هي:
[4 8 6]
 
المثال الثاني:

import numpy as np
 
# NumPy array with elements from 1 to 9
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
 
# Index values can be negative.
arr = x[np.array([1, 3, -3])]
print("\n Elements are : \n",arr)
تشغيل على IDE
انتاج :

العناصر هي:
[2 4 7]
 

أنواع الفهرسة
هناك نوعان من الفهرسة:

التقطيع الأساسي والفهرسة: ضع في اعتبارك بناء الجملة x [obj] حيث x هي المصفوفة و obj هو الفهرس. كائن الشريحة هو الفهرس في حالة التقطيع الأساسي. يحدث التقطيع الأساسي عندما يكون الهدف:

كائن شريحة يكون من النموذج start: stop: step
عدد صحيح
أو مجموعة من كائنات الشرائح والأعداد الصحيحة
جميع المصفوفات التي تم إنشاؤها عن طريق التقطيع الأساسي هي دائمًا طريقة عرض للمصفوفة الأصلية.

كود # 1:

# Python program for basic slicing.
import numpy as np
 
# Arrange elements from 0 to 19
a = np.arange(20)
print("\n Array is:\n ",a)
 
# a[start:stop:step]
print("\n a[-8:17:1]  = ",a[-8:17:1]) 
 
# The : operator means all elements till the end.
print("\n a[10:]  = ",a[10:])
تشغيل على IDE
انتاج :

المصفوفة هي:
[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19]

أ [-8: 17: 1] = [12 13 14 15 16]

أ [10:] = [10 11 12 13 14 15 16 17 18 19]
 
كود # 2:

# Python program for basic slicing 
# and indexing
import numpy as np
 
# A 3-Dimensional array
a = np.array([[0, 1, 2, 3, 4, 5]
              [6, 7, 8, 9, 10, 11]
              [12, 13, 14, 15, 16, 17]
              [18, 19, 20, 21, 22, 23]
              [24, 25, 26, 27, 28, 29]
              [30, 31, 32, 33, 34, 35]]
print("\n Array is:\n ",a)
 
# slicing and indexing
print("\n a[0, 3:5]  = ",a[0, 3:5]) 
 
print("\n a[4:, 4:]  = ",a[4:, 4:]) 
 
print("\n a[:, 2]  = ",a[:, 2]) 
 
print("\n a[2:;2, ::2]  = ",a[2:;2, ::2]) 
تشغيل على IDE
انتاج :

المصفوفة هي:
 [[0 1 2 3 4 5]
  [6 7 8 9 10 11]
  [12 13 14 15 16 17]
  [18 19 20 21 22 23]
  [24 25 26 27 28 29]
  [30 31 32 33 34 35]]

أ [0، 3: 5] = [3 4]

أ [4: ، 4:] = [[28 29] ،
             [34 - 35]

أ [: ، 2] = [2 8 14 20 26 32]

أ [2: ؛ 2 ، :: 2] = [[12 14 16] ،
                [24 26 28]]
يوضح الشكل أدناه المفهوم أكثر وضوحًا:


يمكن أيضًا استخدام القطع الناقص مع التقطيع الأساسي. Ellipsis (...) هو عدد: العناصر المطلوبة لعمل مجموعة اختيار بنفس طول أبعاد المصفوفة.

# Python program for indexing using 
# basic slicing with ellipsis
import numpy as np
 
# A 3 dimensional array.
b = np.array([[[1, 2, 3],[4, 5, 6]],
              [[7, 8, 9],[10, 11, 12]]])
 
print(b[...,1]) #Equivalent to b[: ,: ,1 ]
تشغيل على IDE
انتاج :

[[2 5]
 [8 11]]
 
الفهرسة المتقدمة: يتم تشغيل الفهرسة المتقدمة عندما يكون obj -

ndarray من نوع عدد صحيح أو منطقي
أو مجموعة تحتوي على كائن تسلسل واحد على الأقل
هو كائن غير تسلسل tuple
تقوم الفهرسة المتقدمة بإرجاع نسخة من البيانات بدلاً من طريقة عرض لها. الفهرسة المتقدمة من نوعين صحيحين ومنطقيين.

فهرسة الأعداد الصحيحة البحتة: عند استخدام الأعداد الصحيحة للفهرسة. يتم إقران كل عنصر في البعد الأول بعنصر البعد الثاني. إذن فهرس العناصر في هذه الحالة هو (0،0) ، (1،0) ، (2،1) ويتم تحديد العناصر المقابلة.

# Python program showing advanced indexing
import numpy as np
 
a = np.array([[1 ,2 ],[3 ,4 ],[5 ,6 ]])
print(a[[0 ,1 ,2 ],[0 ,0 ,1]])
تشغيل على IDE
انتاج :

[1 3 6]
الجمع بين الفهرسة المتقدمة والأساسية: عندما يكون هناك شريحة واحدة على الأقل (:) أو علامة حذف (...) أو محور جديد في الفهرس (أو تحتوي المصفوفة على أبعاد أكثر من الفهارس المتقدمة) ، يمكن أن يكون السلوك أكثر تعقيدًا. إنه مثل تسلسل نتيجة الفهرسة لكل عنصر فهرس متقدم

في أبسط الحالات ، لا يوجد سوى فهرس متقدم واحد. يمكن لفهرس متقدم واحد ، على سبيل المثال ، استبدال شريحة وستكون المصفوفة الناتجة هي نفسها ، ومع ذلك ، فهي نسخة وقد يكون لها تخطيط ذاكرة مختلف. يفضل استخدام شريحة عندما يكون ذلك ممكنًا.

# Python program showing advanced 
# and basic indexing
import numpy as np
 
a = np.array([[0 ,1 ,2],[3 ,4 ,5 ],
              [6 ,7 ,8],[9 ,10 ,11]])
 
print(a[1:2 ,1:3 ])
print(a[1:2 ,[1,2]])
تشغيل على IDE
انتاج :

[4 ، 5]
[4 ، 5]
قد تكون أسهل طريقة لفهم الموقف هي التفكير في شكل النتيجة. هناك جزءان لعملية الفهرسة ، المساحة الفرعية المحددة بواسطة الفهرسة الأساسية (باستثناء الأعداد الصحيحة) والفضاء الفرعي من جزء الفهرسة المتقدم. يجب التمييز بين حالتين من تركيبة الفهرس:

يتم فصل الفهارس المتقدمة بواسطة شريحة أو Ellipsis أو newaxis. على سبيل المثال x[arr1, :, arr2].
الفهارس المتقدمة كلها بجوار بعضها البعض. على سبيل المثال x[..., arr1, arr2, :]ولكن ليس x[arr1, :, 1] لأن الرقم 1 هو مؤشر متقدم في هذا الصدد.
في الحالة الأولى ، تأتي الأبعاد الناتجة عن عملية الفهرسة المتقدمة أولاً في مصفوفة النتائج ، وتأتي أبعاد الفضاء الجزئي بعد ذلك. في الحالة الثانية ، يتم إدراج الأبعاد من عمليات الفهرسة المتقدمة في المصفوفة الناتجة في نفس المكان كما كانت في المصفوفة الأولية (المنطق الأخير هو ما يجعل الفهرسة المتقدمة البسيطة تتصرف تمامًا مثل التقطيع).
 
فهرسة المصفوفة المنطقية:
تحتوي هذه الفهرسة على بعض التعبيرات المنطقية مثل الفهرس. يتم إرجاع تلك العناصر التي تلبي هذا التعبير المنطقي. يتم استخدامه لتصفية قيم العنصر المطلوبة.
كود # 1

# You may wish to select numbers greater than 50
import numpy as np
 
a = np.array([10, 40, 80, 50, 100])
print(a[a>50])
تشغيل على IDE
انتاج :

[100 80]
كود # 2

# You may wish to square the multiples of 40 
import numpy as np
 
a = np.array([10, 40, 80, 50, 100])
print(a[a%40==0]**2)
تشغيل على IDE
انتاج :

[1600 6400])
كود # 3

# You may wish to select those elements whose
# sum of row is a multiple of 10.
import numpy as np
 
b = np.array([[5, 5],[4, 5],[16, 4]])
sumrow = b.sum(-1)
print(b[sumrow%10==0])
تشغيل على IDE
انتاج :

مجموعة ([5 ، 5] ، [16 ، 4]])
<<<<<<<<<<<<<<<<<<<
التقطيع الأساسي والفهرسة المتقدمة في NumPy Python
مستوى الصعوبة: متوسط
آخر تحديث: 05 أغسطس 2021
المتطلبات الأساسية: Numpy في Python مقدمة
NumPy أو Numeric Python عبارة عن حزمة للحساب على مصفوفات متجانسة ذات أبعاد n. في الأبعاد الخرسانية تسمى المحاور.

لماذا نحتاج NumPy؟

يطرح سؤال لماذا نحتاج إلى NumPy عندما تكون قوائم Python موجودة بالفعل. الجواب هو أننا لا نستطيع إجراء عمليات على جميع عناصر قائمتين مباشرة. على سبيل المثال ، لا يمكننا ضرب قائمتين مباشرة ، فسيتعين علينا القيام بذلك بطريقة حكيمة. هذا هو المكان الذي يلعب فيه دور NumPy.


# Python program to demonstrate a need of NumPy
 
list1 = [1, 2, 3, 4 ,5, 6]
list2 = [10, 9, 8, 7, 6, 5]
 
# Multiplying both lists directly would give an error.
print(list1*list2)
انتاج : 

TypeError: لا يمكن مضاعفة التسلسل في non-int من النوع "list"
حيث يمكن القيام بذلك بسهولة باستخدام مصفوفات NumPy.

مثال آخر،


# Python program to demonstrate the use of NumPy arrays
import numpy as np
 
list1 = [1, 2, 3, 4, 5, 6]
list2 = [10, 9, 8, 7, 6, 5]
 
# Convert list1 into a NumPy array
a1 = np.array(list1)
 
# Convert list2 into a NumPy array
a2 = np.array(list2)
 
print(a1*a2)
انتاج : 

مجموعة ([10 ، 18 ، 24 ، 28 ، 30 ، 30])
ستساعدك هذه المقالة في التعرف على الفهرسة في NumPy بالتفصيل. حزمة Numpy من python لديها قوة كبيرة في الفهرسة بطرق مختلفة.
 

الفهرسة باستخدام مصفوفات الفهرس

يمكن إجراء الفهرسة في numpy باستخدام مصفوفة كفهرس. في حالة الشرائح ، يتم إرجاع عرض أو نسخة ضحلة من المصفوفة ولكن في مصفوفة الفهرس يتم إرجاع نسخة من المصفوفة الأصلية. يمكن فهرسة المصفوفات Numpy بمصفوفات أخرى أو أي تسلسل آخر باستثناء المجموعات. تتم فهرسة العنصر الأخير بمقدار -1 ثانية أخيرًا بمقدار -2 وهكذا.


# Python program to demonstrate
# the use of index arrays.
import numpy as np
 
# Create a sequence of integers from 10 to 1 with a step of -2
a = np.arrange(10, 1, -2)
print("\n A sequential array with a negative step: \n",a)
 
# Indexes are specified inside the np.array method.
newarr = a[np.array([3, 1, 2 ])]
print("\n Elements at these indices are:\n",newarr)
انتاج : 

مصفوفة متسلسلة بخطوة سالبة:
[10 8 6 4 2]

العناصر في هذه المؤشرات هي:
[4 8 6]
مثال آخر،


import numpy as np
 
# NumPy array with elements from 1 to 9
x = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
 
# Index values can be negative.
arr = x[np.array([1, 3, -3])]
print("\n Elements are : \n",arr)
انتاج : 

العناصر هي:
[2 4 7]
أنواع الفهرسة

هناك نوعان من الفهرسة:

1. التقطيع الأساسي والفهرسة: ضع في اعتبارك بناء الجملة x [obj] حيث x هي المصفوفة و obj هو الفهرس. كائن الشريحة هو الفهرس في حالة التقطيع الأساسي. يحدث التقطيع الأساسي عندما يكون الهدف:

كائن شريحة يكون من النموذج start: stop: step
عدد صحيح
أو مجموعة من كائنات الشرائح والأعداد الصحيحة
جميع المصفوفات التي تم إنشاؤها عن طريق التقطيع الأساسي هي دائمًا طريقة عرض للمصفوفة الأصلية.


# Python program for basic slicing.
import numpy as np
 
# Arrange elements from 0 to 19
a = np.arrange(20)
print("\n Array is:\n ",a)
 
# a[start:stop:step]
print("\n a[-8:17:1] = ",a[-8:17:1])
 
# The : operator means all elements till the end.
print("\n a[10:] = ",a[10:])
انتاج :

المصفوفة هي:
[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19]

أ [-8: 17: 1] = [12 13 14 15 16]

أ [10:] = [10 11 12 13 14 15 16 17 18 19]
يمكن أيضًا استخدام القطع الناقص مع التقطيع الأساسي. Ellipsis (...) هو عدد: العناصر المطلوبة لعمل مجموعة اختيار بنفس طول أبعاد المصفوفة.


# Python program for indexing using basic slicing with ellipsis
import numpy as np
 
# A 3 dimensional array.
b = np.array([[[1, 2, 3],[4, 5, 6]],
            [[7, 8, 9],[10, 11, 12]]])
 
print(b[...,1]) #Equivalent to b[: ,: ,1 ]
انتاج :

[[2 5]
 [8 11]]
2. الفهرسة المتقدمة: يتم تشغيل الفهرسة المتقدمة عندما يكون obj: 

ndarray من نوع عدد صحيح أو منطقي
أو مجموعة تحتوي على كائن تسلسل واحد على الأقل
هو كائن غير تسلسل tuple
تقوم الفهرسة المتقدمة بإرجاع نسخة من البيانات بدلاً من طريقة عرض لها. الفهرسة المتقدمة من نوعين صحيحين ومنطقيين.

فهرسة الأعداد الصحيحة البحتة: عند استخدام الأعداد الصحيحة للفهرسة. يتم إقران كل عنصر في البعد الأول بعنصر البعد الثاني. إذن فهرس العناصر في هذه الحالة هو (0،0) ، (1،0) ، (2،1) ويتم تحديد العناصر المقابلة.


# Python program showing advanced indexing
import numpy as np
 
a = np.array([[1 ,2 ],[3 ,4 ],[5 ,6 ]])
print(a[[0 ,1 ,2 ],[0 ,0 ,1]])
انتاج : 

[1 3 6]
الفهرسة المنطقية 
تحتوي هذه الفهرسة على بعض التعبيرات المنطقية مثل الفهرس. يتم إرجاع تلك العناصر التي تلبي هذا التعبير المنطقي. يتم استخدامه لتصفية قيم العنصر المطلوبة.


# You may wish to select numbers greater than 50
import numpy as np
 
a = np.array([10, 40, 80, 50, 100])
print(a[a>50])
انتاج : 

[100 80]

# You may wish to square the multiples of 40
import numpy as np
 
a = np.array([10, 40, 80, 50, 100])
print(a[a%40==0]**2)
انتاج : 

[1600 6400])

# You may wish to select those elements whose
# sum of row is a multiple of 10.
import numpy as np
 
b = np.array([[5, 5],[4, 5],[16, 4]])
sumrow = b.sum(-1)
print(b[sumrow%10==0])
انتاج : 

مجموعة ([5 ، 5] ، [16 ، 4]])
المرجع: 
SciPy.org
هذا المقال من مساهمة أيوشي أستانا . إذا كنت تحب GeeksforGeeks وترغب في المساهمة ، فيمكنك أيضًا كتابة مقال باستخدام write.geeksforgeeks.org أو إرسال مقالتك بالبريد إلى review-team@geeksforgeeks.org. شاهد مقالتك تظهر على صفحة GeeksforGeeks الرئيسية وساعد المهوسين الآخرين.
يرجى كتابة التعليقات إذا وجدت أي شيء غير صحيح ، أو إذا كنت ترغب في مشاركة المزيد من المعلومات حول الموضوع الذي تمت مناقشته أعلاه.
 

<<<<<<<<<<<<<<<<<<<
نومبي | كائنات نوع البيانات
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
كل ndarray له نوع بيانات مرتبط (نوع dtype). يُعلمنا كائن نوع البيانات (dtype) بتخطيط المصفوفة. هذا يعني أنه يعطينا معلومات حول:

نوع البيانات (عدد صحيح ، عائم ، كائن بايثون ، إلخ.)
حجم البيانات (عدد البايتات)
ترتيب بايت البيانات (صغير أو كبير Endian)
إذا كان نوع البيانات عبارة عن مصفوفة فرعية ، فما هو شكلها ونوع بياناتها.
يتم تخزين قيم ndarray في مخزن مؤقت يمكن اعتباره بمثابة كتلة متجاورة من وحدات بايت الذاكرة. إذن كيف سيتم تفسير هذه البايتات يتم توفيرها من خلال كائن dtype .  

بناء كائن نوع البيانات (نوع البيانات): كائن نوع البيانات هو مثيل لفئة numpy.dtype ويمكن إنشاؤه باستخدام numpy.dtype.

حدود:

obj: الكائن المراد تحويله إلى كائن نوع البيانات.
محاذاة : [منطقي ، اختياري] أضف حشوة إلى الحقول لمطابقة ما قد يخرجه مترجم سي لبنية سي مماثلة.
نسخ : [منطقي ، اختياري] عمل نسخة جديدة من كائن نوع البيانات. إذا كانت False ، فقد تكون النتيجة مجرد مرجع لكائن نوع بيانات مضمن.

# Python Program to create a data type object
import numpy as np
 
# np.int16 is converted into a data type object.
print(np.dtype(np.int16))
تشغيل على IDE
انتاج:

int16
# Python Program to create a data type object 
# containing a 32 bit big-endian integer
import numpy as np
 
# i4 represents integer of size 4 byte
# > represents big-endian byte ordering and
# < represents little-endian encoding.
# dt is a dtype object
dt = np.dtype('>i4')
 
print("Byte order is:",dt.byteorder)
 
print("Size is:", dt.itemsize)
 
print("Data type is:", dt.name)
تشغيل على IDE
انتاج:

ترتيب البايت هو:>
الحجم: 4
اسم نوع البيانات: int32
يمكن أن يتخذ محدد النوع (i4 في الحالة أعلاه) أشكالًا مختلفة:

b1 ، i1 ، i2 ، i4 ، i8 ، u1 ، u2 ، u4 ، u8 ، f2 ، f4 ، f8 ، c8 ، c16 ، a (يمثل البايت ، ints ، ints غير الموقعة ، العوامات ، سلاسل الطول المعقدة والثابتة ذات أطوال بايت محددة )

int8،…، uint8،…، float16، float32، float64، complex64، complex128 (هذه المرة بأحجام بت )

ملاحظة: نوع dtype يختلف عن النوع. 

# Python program to differentiate
# between type and dtype.
import numpy as np
 
a = np.array([1])
 
print("type is: ",type(a))
print("dtype is: ",a.dtype)
تشغيل على IDE
انتاج:

النوع هو:    
نوع dtype هو: int32
 
كائنات نوع البيانات ذات المصفوفات الهيكلية: كائنات نوع البيانات مفيدة لإنشاء مصفوفات منظمة. المصفوفة المهيكلة هي التي تحتوي على أنواع مختلفة من البيانات. يمكن الوصول إلى المصفوفات الهيكلية بمساعدة الحقول.

يشبه الحقل تحديد اسم للكائن. في حالة المصفوفات المهيكلة ، سيتم أيضًا تنظيم كائن dtype. 

# Python program for demonstrating 
# the use of fields
import numpy as np
 
# A structured data type containing a
# 16-character string (in field ‘name’) 
# and a sub-array of two 64-bit floating
# -point number (in field ‘grades’)
 
dt = np.dtype([('name', np.unicode_, 16),
               ('grades', np.float64, (2,))])
 
# Data type of object with field grades
print(dt['grades'])
 
# Data type of object with field name 
print(dt['name'])
تشغيل على IDE
انتاج:

('<f8'، (2،))
# Python program to demonstrate 
# the use of data type object
# with structured array.
import numpy as np
 
dt = np.dtype([('name', np.unicode_, 16),
               ('grades', np.float64, (2,))])
 
# x is a structured array with names
# and marks of students.
# Data type of name of the student is 
# np.unicode_ and data type of marks is 
# np.float(64)
x = np.array([('Sarah', (8.0, 7.0)),
              ('John', (6.0, 7.0))], dtype=dt)
 
print(x[1])
 
print("Grades of John are: ", x[1]['grades'])
print("Names are: ", x['name'])
تشغيل على IDE
انتاج:

("جون" ، [٦ ، ٧])
درجات يوحنا هي: [6. 7.]
الأسماء هي: ["سارة" "جون"]


<<<<<<<<<<<<<<<<<<<
نومبي | التكرار فوق المصفوفة
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
تحتوي حزمة NumPy على كائن مكرر numpy.nditer. إنه كائن مكرر متعدد الأبعاد فعال يمكن استخدامه عبر مصفوفة. تتم زيارة كل عنصر من عناصر المصفوفة باستخدام واجهة التكرار القياسية في Python.

# Python program for
# iterating over array
 
import numpy as geek
 
# creating an array using arrange 
# method
a = geek.arange(12)
 
# shape array with 3 rows and 
# 4 columns
a = a.reshape(3,4)
 
print('Original array is:')
print(a)
print()
 
print('Modified array is:')
 
# iterating  an array
for x in geek.nditer(a):
    print(x)
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

الصفيف المعدل هو:
0 1 2 3 4 5 6 7 8 9 10 11
يتم اختيار ترتيب التكرار لمطابقة تخطيط الذاكرة لمصفوفة ، دون مراعاة ترتيب معين. يمكن ملاحظة ذلك من خلال التكرار على تبديل المصفوفة أعلاه.

# Python program for
# iterating over transpose
# array
 
import numpy as geek 
 
# creating an array using arrange 
# method
a = geek.arange(12)
 
# shape array with 3 rows and 
# 4 columns 
a = a.reshape(3,4) 
    
print('Original array is:')
print(a)
print()  
    
# Transpose of original array
b = a.T 
    
print('Modified array is:')
for x in geek.nditer(b): 
    print(x)
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

الصفيف المعدل هو:
0 1 2 3 4 5 6 7 8 9 10 11
 

التحكم في ترتيب التكرار:
هناك أوقات يكون فيها من المهم زيارة عناصر المصفوفة بترتيب معين ، بغض النظر عن تخطيط العناصر في الذاكرة. يوفر الكائن nditer معلمة ترتيب للتحكم في هذا الجانب من التكرار. الافتراضي ، مع السلوك الموضح أعلاه ، هو order = 'K' للاحتفاظ بالطلب الحالي. يمكن تجاوز هذا الأمر بالطلب = 'C' للأمر C والأمر = 'F' لأمر Fortran.

كود # 1:

# Python program for
# iterating over array
# using particular order
 
import numpy as geek 
 
# creating an array using arrange 
# method
a = geek.arange(12) 
 
# shape array with 3 rows and 
# 4 columns 
a = a.reshape(3,4) 
 
print('Original array is:') 
print(a)
print()  
 
print('Modified array in C-style order:')
 
# iterating an array in a given
# order  
for x in geek.nditer(a, order = 'C'): 
    print(x)
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

مصفوفة معدلة بترتيب نمط C:
0 1 2 3 4 5 6 7 8 9 10 11
 
كود # 2:

# Python program for
# iterating over array
# using particular order
 
import numpy as geek 
 
# creating an array using arrange 
# method
a = geek.arange(0,60,5) 
 
# shape array with 3 rows and 
# 4 columns 
a = a.reshape(3,4) 
 
print('Original array is:') 
print(a)
print()  
 
print('Modified array in F-style order:')
 
# iterating an array in a given
# order   
for x in geek.nditer(a, order = 'F'): 
    print(x)
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

مصفوفة معدلة بترتيب نمط F:
0 4 8 1 5 9 2 6 10 3 7 11
 

تعديل قيم الصفيف:
يحتوي الكائن nditer على معلمة اختيارية أخرى تسمى op_flags . قيمته الافتراضية هي للقراءة فقط ، ولكن يمكن تعيينها على وضع القراءة والكتابة أو الكتابة فقط. سيؤدي هذا إلى تمكين تعديل عناصر المصفوفة باستخدام هذا المكرر.

# Python program for
# modifying array values
 
import numpy as geek
 
# creating an array using arrange 
# method
a = geek.arange(12)
 
# shape array with 3 rows and 
# 4 columns 
a = a.reshape(3,4)
print('Original array is:')
print(a)
print()
 
# modifying array values
for x in geek.nditer(a, op_flags = ['readwrite']):
    x[...] = 5*x
print('Modified array is:')
print(a)
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

الصفيف المعدل هو:
[[0 5 10 15]
 [20 25 30 35]
 [40 45 50 55]]
 

الحلقة الخارجية:

يحتوي nditerمُنشئ الفئة على flagsمعلمة يمكن أن تأخذ القيم التالية

معامل	وصف
حلقة_ خارجية	يتسبب في أن تكون القيم مصفوفات أحادية البعد ذات قيم متعددة بدلاً من المصفوفات ذات الأبعاد الصفرية
c_index	يمكن تتبع فهرس الطلب C
f_index	يتم تتبع فهرس Fortran_order
متعدد الفهرس	يمكن تتبع نوع الفهارس مع واحد لكل تكرار
كود # 1:

# Python program for
# iterating array values
# using external loop
 
import numpy as geek 
 
# creating an array using arrange 
# method
a = geek.arange(12) 
 
# shape array with 3 rows and 
# 4 columns 
a = a.reshape(3,4) 
 
print('Original array is:') 
print(a) 
print()  
 
print('Modified array is:') 
for x in geek.nditer(a, flags = ['external_loop'], order = 'C'):
    print(x)
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

الصفيف المعدل هو:
[0 1 2 3] [4 5 6 7] [8 9 10 11]
 

كود # 2:

# Python program for
# iterating array values
# using f_index
 
import numpy as geek 
 
# creating an array using arrange 
# method
a = geek.arange(6)
 
# shape array with 2 rows and 
# 3 columns 
a = a.reshape(2,3)
 
print('Original array is:')
print(a)
print()
 
# iterating array using f_index 
# parameter
it = geek.nditer(a, flags=['f_index'])
while not it.finished:
      print("%d <%d>" % (it[0], it.index), end=" ")
      it.iternext()
تشغيل على IDE
انتاج:

المجموعة الأصلية هي:
[[0 1 2]
 [3 4 5]]

0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5>
 

تكرار البث:
إذا كانت مصفوفتان قابلتين للإذاعة ، فإن كائن nditer المركب قادر على التكرار عليهما في نفس الوقت. بافتراض أن المصفوفة أ لها أبعاد 3 × 4 ، وهناك مصفوفة أخرى ب ذات البعد 1 × 4 ، يتم استخدام مكرر النوع التالي (يتم بث المصفوفة ب إلى حجم أ).

# Python program for
# iterating array 
 
import numpy as geek
 
# creating an array using arrange 
# method 
a = geek.arange(12)
 
 # shape array with 3 rows and 
# 4 columns 
a = a.reshape(3,4) 
 
print('First array is:') 
print(a)
print()  
 
# Creating second array using 
# array method
print('Second array is:') 
b = geek.array([5, 6, 7, 8], dtype = int) 
print(b)  
print() 
 
print('Modified array is:')
for x,y in geek.nditer([a,b]): 
    print("%d:%d" % (x,y))
تشغيل على IDE
انتاج:

المصفوفة الأولى هي:
[[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

المجموعة الثانية هي:
[5 6 7 8]

الصفيف المعدل هو:
0: 5 1: 6 2: 7 3: 8 4: 5 5: 6 6: 7 7: 8 8: 5 9: 6 10: 7 11: 8
 
<<<<<<<<<<<<<<<<<<<
نومبي | العمليات الثنائية
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
العوامل الثنائية تعمل على البتات وتنفذ العملية شيئا فشيئا. العملية الثنائية هي ببساطة قاعدة لدمج قيمتين لإنشاء قيمة جديدة.

numpy.bitwise_and () : تُستخدم هذه الوظيفة لحساب البت الحكيملعنصر الصفيف. تحسب هذه الوظيفة من ناحية البتات والتمثيل الثنائي الأساسي للأعداد الصحيحة في مصفوفات الإدخال.

كود # 1:

# Python program explaining
# bitwise_and() function
 
import numpy as geek
in_num1 = 10
in_num2 = 11
 
print ("Input  number1 : ", in_num1)
print ("Input  number2 : ", in_num2) 
   
out_num = geek.bitwise_and(in_num1, in_num2) 
print ("bitwise_and of 10 and 11 : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال 1: 10
رقم الإدخال 2: 11
bitwise_and 10 و 11: 10
 
كود # 2:

# Python program explaining
# bitwise_and() function
 
import numpy as geek
 
in_arr1 = [2, 8, 125]
in_arr2 = [3, 3, 115]
  
print ("Input array1 : ", in_arr1) 
print ("Input array2 : ", in_arr2)
   
out_arr = geek.bitwise_and(in_arr1, in_arr2) 
print ("Output array after bitwise_and: ", out_arr) 
تشغيل على IDE
انتاج :

مصفوفة الإدخال 1: [2، 8، 125]
مصفوفة الإدخال 2: [3، 3، 115]
مصفوفة الإخراج بعد bitwise_and: [2 0 113]
 
numpy.bitwise_or () : تُستخدم هذه الوظيفة لحساب OR على مستوى البت لاثنين من عناصر المصفوفة. تحسب هذه الوظيفة المعامل OR على مستوى البت للتمثيل الثنائي الأساسي للأعداد الصحيحة في مصفوفات الإدخال.

كود # 1:

# Python program explaining
# bitwise_or() function
 
import numpy as geek
in_num1 = 10
in_num2 = 11
 
print ("Input  number1 : ", in_num1)
print ("Input  number2 : ", in_num2) 
   
out_num = geek.bitwise_or(in_num1, in_num2) 
print ("bitwise_or of 10 and 11 : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال 1: 10
رقم الإدخال 2: 11
bitwise_or 10 و 11: 11
 
كود # 2:

# Python program explaining
# bitwise_or() function
 
import numpy as geek
 
in_arr1 = [2, 8, 125]
in_arr2 = [3, 3, 115]
  
print ("Input array1 : ", in_arr1) 
print ("Input array2 : ", in_arr2)
   
out_arr = geek.bitwise_or(in_arr1, in_arr2) 
print ("Output array after bitwise_or: ", out_arr) 
تشغيل على IDE
انتاج :

مصفوفة الإدخال 1: [2، 8، 125]
مصفوفة الإدخال 2: [3، 3، 115]
صفيف الإخراج بعد bitwise_or: [3 11 127]
 
numpy.bitwise_xor () : تُستخدم هذه الوظيفة لحساب XOR بت الحكمةمن عنصرين من عناصر المصفوفة. تحسب هذه الوظيفة XOR من ناحية البت للتمثيل الثنائي الأساسي للأعداد الصحيحة في مصفوفات الإدخال.

كود # 1:

# Python program explaining
# bitwise_xor() function
 
import numpy as geek
in_num1 = 10
in_num2 = 11
 
print ("Input  number1 : ", in_num1)
print ("Input  number2 : ", in_num2) 
   
out_num = geek.bitwise_xor(in_num1, in_num2) 
print ("bitwise_xor of 10 and 11 : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال 1: 10
رقم الإدخال 2: 11
bitwise_xor 10 و 11: 1
 
كود # 2:

# Python program explaining
# bitwise_xor() function
 
import numpy as geek
 
in_arr1 = [2, 8, 125]
in_arr2 = [3, 3, 115]
  
print ("Input array1 : ", in_arr1) 
print ("Input array2 : ", in_arr2)
   
out_arr = geek.bitwise_xor(in_arr1, in_arr2) 
print ("Output array after bitwise_xor: ", out_arr) 
تشغيل على IDE
انتاج :

مصفوفة الإدخال 1: [2، 8، 125]
مصفوفة الإدخال 2: [3، 3، 115]
صفيف الإخراج بعد bitwise_xor: [1 11 14]
 
numpy.invert () : تُستخدم هذه الوظيفة لحساب انعكاس البت في عنصر المصفوفة. وهي تحسب البتات NOT للتمثيل الثنائي الأساسي للأعداد الصحيحة في مصفوفات الإدخال.
بالنسبة لمدخلات الأعداد الصحيحة الموقعة ، يتم إرجاع مكمل الاثنين. في نظام ثنائي مكمل ، يتم تمثيل الأرقام السالبة من خلال تكملة الاثنين للقيمة المطلقة.

كود # 1:

# Python program explaining
# invert() function
 
import numpy as geek
in_num = 10
print ("Input  number : ", in_num)
   
out_num = geek.invert(in_num) 
print ("inversion of 10 : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال: 10
انقلاب 10: -11
 
كود # 2:

# Python program explaining
# invert() function
 
import numpy as geek
 
in_arr = [2, 0, 25]
print ("Input array : ", in_arr)
   
out_arr = geek.invert(in_arr) 
print ("Output array after inversion: ", out_arr) 
تشغيل على IDE
انتاج :

مصفوفة الإدخال: [2 ، 0 ، 25]
صفيف الإخراج بعد الانعكاس: [-3 -1 -26]
 
numpy.left_shift () : تُستخدم هذه الوظيفة لتحويل بتات عدد صحيح إلى اليسار. يتم إزاحة البتات إلى اليسار عن طريق إلحاق arr2 0s (أصفار) على يمين arr1. نظرًا لأن التمثيل الداخلي للأرقام في تنسيق ثنائي ، فإن هذه العملية تعادل ضرب arr1 في 2 ** arr2. على سبيل المثال ، إذا كان الرقم 5 ونريد التحول إلى اليسار بمقدار 2 بت ، فستكون النتيجة 5 * (2 ^ 2) = 20

كود # 1:

# Python program explaining
# left_shift() function
 
import numpy as geek
in_num = 5
bit_shift = 2
 
print ("Input  number : ", in_num)
print ("Number of bit shift : ", bit_shift ) 
   
out_num = geek.left_shift(in_num, bit_shift) 
print ("After left shifting 2 bit  : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال: 5
عدد إزاحة البتات: 2
بعد إزاحة اليسار 2 بت: 20
 
كود # 2:

# Python program explaining
# left_shift() function
 
import numpy as geek
 
in_arr = [2, 8, 15]
bit_shift =[3, 4, 5]
  
print ("Input array : ", in_arr) 
print ("Number of bit shift : ", bit_shift)
   
out_arr = geek.left_shift(in_arr, bit_shift) 
print ("Output array after left shifting: ", out_arr) 
تشغيل على IDE
انتاج :

صفيف الإدخال: [2 ، 8 ، 15]
عدد إزاحة البتات: [3 ، 4 ، 5]
صفيف الإخراج بعد التحول إلى اليسار: [16128 480]
 
numpy.right_shift () : تُستخدم هذه الوظيفة لتحويل بتات عدد صحيح إلى اليمين. نظرًا لأن التمثيل الداخلي للأرقام بتنسيق ثنائي ، فإن هذه العملية تعادل قسمة arr1 على 2 ** arr2. على سبيل المثال ، إذا كان الرقم 20 ونريد التحول إلى اليمين بمقدار 2 بت ، فستكون النتيجة 20 / (2 ^ 2) = 5.

كود # 1:

# Python program explaining
# right_shift() function
 
import numpy as geek
in_num = 20
bit_shift = 2
 
print ("Input  number : ", in_num)
print ("Number of bit shift : ", bit_shift ) 
   
out_num = geek.right_shift(in_num, bit_shift) 
print ("After right shifting 2 bit  : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال: 20
عدد إزاحة البتات: 2
بعد التحويل الصحيح 2 بت: 5
 
كود # 2:

# Python program explaining
# right_shift() function
 
import numpy as geek
 
in_arr = [24, 48, 16]
bit_shift =[3, 4, 2]
  
print ("Input array : ", in_arr) 
print ("Number of bit shift : ", bit_shift)
   
out_arr = geek.right_shift(in_arr, bit_shift) 
print ("Output array after right shifting: ", out_arr) 
تشغيل على IDE
انتاج :

مصفوفة الإدخال: [24 ، 48 ، 16]
عدد إزاحة البتات: [3 ، 4 ، 2]
صفيف الإخراج بعد التحول الأيمن: [3 3 4]
 
numpy.binary_repr (number، width = None) : تُستخدم هذه الوظيفة لتمثيل الشكل الثنائي لرقم الإدخال كسلسلة. بالنسبة للأرقام السالبة ، إذا لم يتم إعطاء العرض ، تضاف علامة الطرح إلى المقدمة. إذا تم توفير العرض ، فسيتم إرجاع مكمل الرقمين ، فيما يتعلق بهذا العرض.
في نظام مكمل اثنين ، يتم تمثيل الأرقام السالبة بمكمل الاثنين للقيمة المطلقة. هذه هي الطريقة الأكثر شيوعًا لتمثيل الأعداد الصحيحة الموقعة على أجهزة الكمبيوتر.

كود # 1:

# Python program explaining
# binary_repr() function
 
import numpy as geek
in_num = 10
 
print ("Input  number : ", in_num)
 
out_num = geek.binary_repr(in_num) 
print ("binary representation of 10 : ", out_num) 
تشغيل على IDE
انتاج :

رقم الإدخال: 10
تمثيل ثنائي 10: 1010
 
كود # 2:

# Python program explaining
# binary_repr() function
import numpy as geek
 
in_arr = [5, -8 ]
  
print ("Input array : ", in_arr) 
 
# binary representation of first array  
# element without using width parameter
out_num = geek.binary_repr(in_arr[0])
print("Binary representation of 5")
print ("Without using width parameter : ", out_num) 
 
# binary representation of first array
# element using width parameter
out_num = geek.binary_repr(in_arr[0], width = 5)
print ("Using width parameter: ", out_num) 
 
print("\nBinary representation of -8")
 
# binary representation of 2nd array
# element without using width parameter
out_num = geek.binary_repr(in_arr[1])
print ("Without using width parameter : ", out_num) 
 
# binary representation of 2nd array
# element  using width parameter
out_num = geek.binary_repr(in_arr[1], width = 5)
print ("Using width parameter : ", out_num) 
تشغيل على IDE
انتاج :

مصفوفة الإدخال: [5، -8]
التمثيل الثنائي 5
بدون استخدام معلمة العرض: 101
باستخدام معلمة العرض: 00101

التمثيل الثنائي -8  
بدون استخدام معلمة العرض: -1000
باستخدام معلمة العرض: 11000
numpy.packbits (myarray، axis = None): تُستخدم هذه الوظيفة لتجميع عناصر مصفوفة ثنائية القيمة في وحدات بت في مصفوفة uint8 ، وتكون النتيجة مبطنًا بالبايت الكامل عن طريق إدخال صفر بت في النهاية.

كود # 1:

# Python program explaining
# packbits() function
import numpy as np
 
# creating an array using 
# array function
a = np.array([[[1,0,1],
             [0,1,0]],
             [[1,1,0],
             [0,0,1]]])
 
# packing elements of an array
# using packbits() function
b = np.packbits(a, axis=-1)
 
print(b)
تشغيل على IDE
انتاج :

[[160] ، [64]] ، [[192] ، [32]]]
 
numpy.unpackbits (myarray، axis = None): تُستخدم هذه الوظيفة لفك حزم عناصر مصفوفة uint8 إلى مصفوفة مخرجات ذات قيمة ثنائية ، ويمثل كل عنصر في myarray حقل بت يجب فك حزمه في مصفوفة مخرجات ثنائية القيمة . يكون شكل صفيف الإخراج إما 1-D (إذا كان المحور بلا) أو نفس شكل صفيف الإدخال مع التفريغ على طول المحور المحدد.

كود # 1:

# Python program explaining
# unpackbits() function
import numpy as np
 
# creating an array using 
# array function
a = np.array([[2], [7], [23]], dtype=np.uint8)
 
# packing elements of an array
# using packbits() function
b = np.unpackbits(a, axis = 1)
 
print(b)
تشغيل على IDE
انتاج :

[[0 ، 0 ، 0 ، 0 ، 0 ، 0 ، 1 ، 0] ،
 [0 ، 0 ، 0 ، 0 ، 0 ، 1 ، 1 ، 1] ،
 [0 ، 0 ، 0 ، 1 ، 0 ، 1 ، 1 ، 1]]
 
<<<<<<<<<<<<<<<<<<
نومبي | دالة رياضية
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
يحتوي NumPy على عدد كبير من العمليات الحسابية المختلفة. يوفر NumPy وظائف مثلثية قياسية ووظائف للعمليات الحسابية ومعالجة الأرقام المعقدة وما إلى ذلك.

الدوال المثلثية -
يحتوي NumPy على دوال مثلثية قياسية تعيد النسب المثلثية لزاوية معينة بوحدات الراديان.

numpy.sin (x [، out]) = ufunc 'sin') : تساعد هذه الوظيفة الرياضية المستخدم على حساب الجيب المثلث لكل x (كونها عناصر المصفوفة).

# Python program explaining
# sin() function
 
import numpy as np
import math
 
in_array = [0, math.pi / 2, np.pi / 3, np.pi]
print ("Input array : \n", in_array)
 
Sin_Values = np.sin(in_array)
print ("\nSine values : \n", Sin_Values)
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0، 1.5707963267948966، 1.0471975511965976، 3.141592653589793]

قيم الجيب:
 [0.00000000e + 00 1.00000000e + 00 8.66025404e-01 1.22464680e-16]
 
numpy.cos (x [، out]) = ufunc 'cos') : تساعد هذه الوظيفة الرياضية المستخدم على حساب جيب التمام المثلث لكل x (كونها عناصر المصفوفة).

# Python program explaining
# cos() function
 
import numpy as np
import math
 
in_array = [0, math.pi / 2, np.pi / 3, np.pi]
print ("Input array : \n", in_array)
 
cos_Values = np.cos(in_array)
print ("\nCosine values : \n", cos_Values)
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0، 1.5707963267948966، 1.0471975511965976، 3.141592653589793]

قيم جيب التمام:
 [1.00000000e + 00 6.12323400e-17 5.00000000e-01-1.00000000e + 00]
 

دور	وصف
تان ()	حساب عنصر الظل من الحكمة.
أركسين ()	الجيب المعكوس ، العنصر الحكيم.
arccos ()	جيب التمام العكسي المثلثي ، من حيث العناصر.
أركتان ()	الظل المعكوس المثلثي ، عنصر الحكمة.
arctan2 ()	ظل قوس العنصر من x1 / x2 اختيار الربع بشكل صحيح.
درجات()	تحويل الزوايا من الراديان إلى درجات.
rad2deg ()	تحويل الزوايا من الراديان إلى درجات.
deg2rad	تحويل الزوايا من درجات إلى راديان.
راديان()	تحويل الزوايا من درجات إلى راديان.
وتر ()	بالنظر إلى "أرجل" المثلث القائم ، أعد الوتر.
بسط()	قم بفك التفاف عن طريق تغيير دلتا بين القيم إلى 2 * pi تكملة.
الدوال الزائدية -
numpy.sinh (x [، out]) = ufunc 'sin') : تساعد هذه الوظيفة الرياضية المستخدم على حساب الجيب الزائدي لكل x (كونها عناصر المصفوفة).

يعادل 1/2 * (np.exp(x) - np.exp(-x)) or -1j * np.sin(1j*x).

# Python3 program explaining
# sinh() function
 
import numpy as np
import math
 
in_array = [0, math.pi / 2, np.pi / 3, np.pi]
print ("Input array : \n", in_array)
 
Sinh_Values = np.sinh(in_array)
print ("\nSine Hyperbolic values : \n", Sinh_Values)
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0، 1.5707963267948966، 1.0471975511965976، 3.141592653589793]

قيم الجيب الزائدية:
 [0. 2.3012989 1.24936705 11.54873936]
 
numpy.cosh (x [، out]) = ufunc 'cos') : تساعد هذه الوظيفة الرياضية المستخدم على حساب جيب التمام الزائدي لكل x (كونها عناصر المصفوفة).

يعادل 1/2 * (np.exp(x) - np.exp(-x))وnp.cos(1j*x)

# Python3 program explaining
# cosh() function
 
import numpy as np
import math
 
in_array = [0, math.pi / 2, np.pi / 3, np.pi]
print ("Input array : \n", in_array)
 
cosh_Values = np.cosh(in_array)
print ("\ncosine Hyperbolic values : \n", cosh_Values)
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0، 1.5707963267948966، 1.0471975511965976، 3.141592653589793]

القيم الزائدية لجيب التمام:
 [1. 2.50917848 1.60028686 11.59195328]
 

دور	وصف
تانه ()	حساب عنصر الظل الزائدي من الحكمة.
arcsinh ()	الجيب الزائدي المعكوس من حيث العنصر.
أركوش ()	جيب التمام الزائدي المعكوس ، من حيث العناصر.
arctanh ()	المماس المعكوس الزائدي من الحكمة.
دوال التقريب -
numpy.around (arr، decimals = 0، out = None) : تساعد هذه الوظيفة الرياضية المستخدم على تقريب عناصر المصفوفة بالتساوي إلى العدد المحدد من الكسور العشرية.

# Python program explaining
# around() function
 
import numpy as np
 
in_array = [.5, 1.5, 2.5, 3.5, 4.5, 10.1]
print ("Input array : \n", in_array)
 
round_off_values = np.around(in_array)
print ("\nRounded values : \n", round_off_values)
 
 
in_array = [.53, 1.54, .71]
print ("\nInput array : \n", in_array)
 
round_off_values = np.around(in_array)
print ("\nRounded values : \n", round_off_values)
 
in_array = [.5538, 1.33354, .71445]
print ("\nInput array : \n", in_array)
 
round_off_values = np.around(in_array, decimals = 3)
print ("\nRounded values : \n", round_off_values)
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0.5 ، 1.5 ، 2.5 ، 3.5 ، 4.5 ، 10.1]

القيم المقربة:
 [0. 2. 2. 4. 4. 10.]

صفيف الإدخال:
 [0.53 ، 1.54 ، 0.71]

القيم المقربة:
 [1. 2. 1.]

صفيف الإدخال:
 [0.5538 ، 1.33354 ، 0.71445]

القيم المقربة:
 [0.554 1.334 0.714]
 
numpy.round_ (arr، decimals = 0، out = None) : تُقرب هذه الدالة الحسابية مصفوفة إلى العدد المحدد من الكسور العشرية.

# Python program explaining
# round_() function
import numpy as np
 
in_array = [.5, 1.5, 2.5, 3.5, 4.5, 10.1]
print ("Input array : \n", in_array)
 
round_off_values = np.round_(in_array)
print ("\nRounded values : \n", round_off_values)
 
 
in_array = [.53, 1.54, .71]
print ("\nInput array : \n", in_array)
 
round_off_values = np.round_(in_array)
print ("\nRounded values : \n", round_off_values)
 
in_array = [.5538, 1.33354, .71445]
print ("\nInput array : \n", in_array)
 
round_off_values = np.round_(in_array, decimals = 3)
print ("\nRounded values : \n", round_off_values)
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0.5 ، 1.5 ، 2.5 ، 3.5 ، 4.5 ، 10.1]

القيم المقربة:
 [0. 2. 2. 4. 4. 10.]

صفيف الإدخال:
 [0.53 ، 1.54 ، 0.71]

القيم المقربة:
 [1. 2. 1.]

صفيف الإدخال:
 [0.5538 ، 1.33354 ، 0.71445]

القيم المقربة:
 [0.554 1.334 0.714]
 

دور	وصف
طبع ()	قرّب لأقرب عدد صحيح باتجاه الصفر.
يصلح()	قرّب لأقرب عدد صحيح باتجاه الصفر.
أرضية()	أعد أرضية الإدخال ، من حيث العناصر.
سقف()	أعد سقف المدخلات ، من حيث العناصر.
trunc ()	إرجاع القيمة المقتطعة للإدخال ، حسب العنصر.
دوال الأس واللوغاريتمات -
numpy.exp (مصفوفة ، خارج = لا شيء ، حيث = True ، casting = 'same_kind' ، order = 'K' ، dtype = None) : تساعد هذه الوظيفة الرياضية المستخدم على حساب أسي لجميع العناصر في مجموعة الإدخال.

# Python program explaining
# exp() function
import numpy as np
 
in_array = [1, 3, 5]
print ("Input array : ", in_array)
 
out_array = np.exp(in_array)
print ("Output array : ", out_array)
تشغيل على IDE
انتاج :

مصفوفة الإدخال: [1 ، 3 ، 5]
مصفوفة الإخراج: [2.71828183 20.08553692 148.4131591]
 
numpy.log (x [، out] = ufunc 'log1p') : تساعد هذه الوظيفة الرياضية المستخدم على حساب اللوغاريتم الطبيعي لـ x حيث ينتمي x إلى جميع عناصر مصفوفة الإدخال.
اللوغاريتم الطبيعي اللوغاريتم هو معكوس exp () ، لذلكlog(exp(x)) = x. اللوغاريتم الطبيعي هو لوغاريتم الأساس e.

# Python program explaining
# log() function
import numpy as np
 
in_array = [1, 3, 5, 2**8]
print ("Input array : ", in_array)
 
out_array = np.log(in_array)
print ("Output array : ", out_array)
 
 
print("\nnp.log(4**4) : ", np.log(4**4))
print("np.log(2**8) : ", np.log(2**8))
تشغيل على IDE
انتاج :

مصفوفة الإدخال: [1، 3، 5، 256]
مصفوفة الإخراج: [0. 1.09861229 1.60943791 5.54517744]

np.log (4 ** 4): 5.54517744448
np.log (2 ** 8): 5.54517744448
 

دور	وصف
expm1 ()	احسب exp (x) - 1 لجميع العناصر في المصفوفة.
إكسب 2 ()	احسب 2 ** p لكل p في مصفوفة الإدخال.
log10 ()	قم بإرجاع اللوغاريتم الأساسي 10 لمصفوفة الإدخال ، حسب العناصر.
log2 ()	الأساس -2 لوغاريتم x.
log1p ()	قم بإرجاع اللوغاريتم الطبيعي لواحد بالإضافة إلى مصفوفة الإدخال ، حسب العناصر.
logaddexp ()	لوغاريتم مجموع أسي المدخلات.
logaddexp2 ()	لوغاريتم مجموع الأس للمدخلات في الأساس -2.
الدالات الحسابية -
numpy.reciprocal (x، /، out = None، *، where = True) : تُستخدم هذه الدالة الرياضية لحساب مقلوب جميع العناصر في مصفوفة الإدخال.

ملاحظة: بالنسبة إلى وسيطات الأعداد الصحيحة ذات القيمة المطلقة الأكبر من 1 ، تكون النتيجة دائمًا صفرًا بسبب طريقة تعامل Python مع قسمة الأعداد الصحيحة. بالنسبة إلى العدد الصحيح صفر ، تكون النتيجة تجاوز السعة.

# Python3 code demonstrate reciprocal() function
 
# importing numpy
import numpy as np
 
in_num = 2.0
print ("Input  number : ", in_num)
 
out_num = np.reciprocal(in_num)
print ("Output number : ", out_num)
تشغيل على IDE
انتاج :

رقم الإدخال: 2.0
رقم الإخراج: 0.5
 
numpy.divide (arr1، arr2، out = None، حيث = True، casting = 'same_kind'، order = 'K'، dtype = None) : عنصر المصفوفة من المصفوفة الأولى مقسوم على عناصر من العنصر الثاني (كل عنصر يحدث- حكمة). يجب أن يكون لكل من arr1 و arr2 نفس الشكل ويجب ألا يكون العنصر في arr2 صفرًا ؛ وإلا فإنه سوف يثير خطأ.

# Python program explaining
# divide() function
import numpy as np
 
# input_array
arr1 = [2, 27, 2, 21, 23]
arr2 = [2, 3, 4, 5, 6]
print ("arr1         : ", arr1)
print ("arr2         : ", arr2)
 
# output_array
out = np.divide(arr1, arr2)
print ("\nOutput array : \n", out)
تشغيل على IDE
انتاج :

arr1: [2، 27، 2، 21، 23]
arr2: [2، 3، 4، 5، 6]

مجموعة الإخراج:
 [1. 9. 0.5 4.2 3.83333333]
 

دور	وصف
يضيف()	أضف الوسيطات من حيث العنصر.
إيجابي()	العددية الموجبة ، من حيث العناصر.
نفي()	عددي سلبي ، عنصر الحكمة.
تتضاعف()	اضرب الوسيطات بحكمة العنصر.
قوة()	عناصر المصفوفة الأولى مرفوعة إلى قوى من المصفوفة الثانية ، عنصر الحكمة.
طرح او خصم()	اطرح الحجج ، من حيث العنصر.
تقسيم صحيح ()	إرجاع القسمة الحقيقية للمدخلات ، من حيث العناصر.
تقسيم_الطابق ()	إرجاع أكبر عدد صحيح أصغر أو يساوي قسمة المدخلات.
float_power ()	عناصر المصفوفة الأولى مرفوعة إلى قوى من المصفوفة الثانية ، عنصر الحكمة.
عصري()	إعادة ما تبقى من عنصر الحكمة من القسمة.
بقية()	إرجاع العنصر الحكيم المتبقي من القسمة.
divmod ()	إرجاع حاصل العنصر الحكيم والباقي في وقت واحد.
دالة الرقم المركب -
numpy.isreal (المصفوفة) : اختبر ما إذا كان رقمًا حقيقيًا أم لا (ليس ما لا نهاية أو ليس رقمًا) وإرجاع النتيجة كمصفوفة منطقية.

# Python Program illustrating
# numpy.isreal() method
  
import numpy as geek 
 
print("Is Real : ", geek.isreal([1+1j, 0j]), "\n")
 
print("Is Real : ", geek.isreal([1, 0]), "\n")
تشغيل على IDE
انتاج :

هل حقيقي: [خطأ صحيح]

هو حقيقي: [صحيح صحيح]
numpy.conj (x [، out] = ufunc 'conjugate') : تساعد هذه الوظيفة المستخدم على تصريف أي رقم مركب.
يتم الحصول على اقتران العدد المركب عن طريق تغيير إشارة الجزء التخيلي منه. إذا كان العدد المركب 2 + 5j فإن مرافقه يكون 2-5j.

# Python3 code demonstrate conj() function
 
#importing numpy
import numpy as np
 
in_complx1 = 2+4j
out_complx1 = np.conj(in_complx1)
print ("Output conjugated complex number of  2+4j : ", out_complx1)
 
in_complx2 =5-8j
out_complx2 = np.conj(in_complx2)
print ("Output conjugated complex number of 5-8j: ", out_complx2)
تشغيل على IDE
انتاج :

العدد المركب المترافق الناتج 2 + 4j: (2-4j)
العدد المركب المترافق الناتج من 5-8j: (5 + 8j)
 
الدوال الخاصة -
numpy.cbrt (arr، out = None، ufunc 'cbrt') : تساعد هذه الوظيفة الرياضية المستخدم على حساب الجذر التكعيبي لـ x لجميع عناصر المصفوفة x.

# Python program explaining
# cbrt () function
  
import numpy as np
  
arr1 = [1, 27000, 64, -1000]
print ("cbrt Value of arr1 : \n", np.cbrt(arr1))
  
arr2 = [1024 ,-128]
print ("\ncbrt Value of arr2 : ", np.cbrt(arr2))
تشغيل على IDE
انتاج :

قيمة cbrt لـ arr1:
 [1. 30. 4. -10.]

قيمة cbrt لـ arr2: [10.0793684 -5.0396842]
 
numpy.clip () : تُستخدم هذه الوظيفة لقص (تحديد) القيم في المصفوفة.
بالنظر إلى الفاصل الزمني ، يتم قص القيم الموجودة خارج الفاصل الزمني إلى حواف الفاصل الزمني. على سبيل المثال ، إذا تم تحديد فاصل زمني [0 ، 1] ، فإن القيم الأصغر من 0 تصبح 0 ، والقيم الأكبر من 1 تصبح 1.

# Python3 code demonstrate clip() function
 
# importing the numpy
import numpy as np
 
in_array = [1, 2, 3, 4, 5, 6, 7, 8 ]
print ("Input array : ", in_array)
 
out_array = np.clip(in_array, a_min = 2, a_max = 6)
print ("Output array : ", out_array)
تشغيل على IDE
انتاج :

مصفوفة الإدخال: [1 ، 2 ، 3 ، 4 ، 5 ، 6 ، 7 ، 8]
مصفوفة الإخراج: [2 2 3 4 5 6 6 6]
 

دور	وصف
تلتف ()	إرجاع الالتواء الخطي المنفصل لتتابعين أحاديي البعد.
الجذر التربيعي ()	قم بإرجاع الجذر التربيعي غير السالب لمصفوفة ، حسب العنصر.
ميدان()	أعد مربع العنصر الحكيم للإدخال.
مطلق()	احسب القيمة المطلقة من حيث العنصر.
القوات المسلحة البوروندية ()	حساب القيم المطلقة من حيث العنصر.
إشارة()	إرجاع إشارة عنصر الحكمة لعلامة رقم.
انترب ()	الاستيفاء الخطي أحادي البعد.
أقصى()	الحد الأقصى من عنصر الحكمة من عناصر المصفوفة.
الحد الأدنى()	الحد الأدنى من عنصر الحكمة من عناصر المصفوفة.
real_if_close ()	إذا كانت المدخلات المعقدة ترجع مصفوفة حقيقية إذا كانت الأجزاء المعقدة قريبة من الصفر.
nan_to_num ()	استبدل NaN بالصفر واللانهاية بأرقام محدودة كبيرة.
هيفيسايد ()	احسب دالة خطوة Heaviside.


<<<<<<<<<<<<<<<<<<
نومبي | عمليات السلاسل
آخر تحديث: 19 أبريل 2020
تُستخدم هذه الوحدة لإجراء عمليات سلسلة متجهية لمصفوفات من نوع dtype numpy.string_ أو numpy.unicode_. تستند جميعها إلى وظائف السلسلة القياسية في مكتبة Python المدمجة.

String Operations -
numpy.lower () : تُرجع هذه الدالة السلسلة الصغيرة من السلسلة المحددة. يقوم بتحويل جميع الأحرف الكبيرة إلى أحرف صغيرة. في حالة عدم وجود أحرف كبيرة ، يتم إرجاع السلسلة الأصلية.

# Python program explaining
# numpy.lower() function
 
import numpy as np
 
# converting to lowercase
print(np.char.lower(['GEEKS', 'FOR']))
 
# converting to lowercase
print(np.char.lower('GEEKS'))
تشغيل على IDE
انتاج :

["المهوسون" لـ "]
المهوسون
 
numpy.split () : تقوم هذه الوظيفة بإرجاع قائمة من السلاسل بعد كسر السلسلة المحددة بواسطة الفاصل المحدد.

# Python program explaining
# numpy.split() function
 
import numpy as np
 
# splitting a string
print(np.char.split('geeks for geeks'))
 
# splitting a string
print(np.char.split('geeks, for, geeks', sep = ','))
تشغيل على IDE
انتاج :

['geeks'، 'for'، 'geeks']
['geeks'، 'for'، 'geeks']
 
numpy.join () : هذه الوظيفة عبارة عن عملية سلسلة وترجع سلسلة تم فيها ضم عناصر التسلسل بواسطة فاصل str.

# Python program explaining
# numpy.join() function
 
import numpy as np
 
# splitting a string
print(np.char.join('-', 'geeks'))
 
# splitting a string
print(np.char.join(['-', ':'], ['geeks', 'for']))
تشغيل على IDE
انتاج :

المهوسون
['geeks'، 'g: e: e: k: s']
 

دور	وصف
numpy.strip ()	يتم استخدامه لإزالة جميع المسافات البادئة والزائدة من سلسلة.
numpy.capitalize ()	يحول الحرف الأول من السلسلة إلى حرف كبير (كبير). إذا كانت السلسلة تحتوي على حرفها الأول كعاصمة ، فإنها تُرجع السلسلة الأصلية.
numpy.center ()	يقوم بإنشاء وإرجاع سلسلة جديدة مبطنة بالحرف المحدد ..
numpy.decode ()	يتم استخدامه للتحويل من مخطط تشفير واحد ، حيث يتم تشفير سلسلة الوسيطة إلى مخطط التشفير المطلوب.
numpy.encode ()	إرجاع السلسلة بالصيغة المشفرة
numpy.ljust ()	قم بإرجاع مصفوفة تحتوي على عناصر ضبط إلى اليسار في سلسلة طولها عرض.
numpy.rjust ()	لكل عنصر في a ، قم بإرجاع نسخة مع إزالة الأحرف البادئة.
numpy.strip ()	لكل عنصر في a ، قم بإرجاع نسخة مع إزالة الأحرف البادئة والتابعة.
numpy.lstrip ()	تحويل الزوايا من درجات إلى راديان.
numpy.rstrip ()	لكل عنصر في a ، قم بإرجاع نسخة مع إزالة الأحرف اللاحقة.
numpy.partition ()	قسم كل عنصر في حوالي سبتمبر.
numpy.r partition	قسم (انقسام) كل عنصر حول الفاصل الموجود في أقصى اليمين.
numpy.rsplit ()	لكل عنصر في a ، قم بإرجاع قائمة بالكلمات الموجودة في السلسلة ، باستخدام sep كسلسلة محددة.
numpy.title ()	يتم استخدامه لتحويل الحرف الأول في كل كلمة إلى أحرف كبيرة والأحرف المتبقية إلى أحرف صغيرة في سلسلة وإرجاع سلسلة جديدة.
numpy.upper ()	ترجع السلسلة ذات الأحرف الكبيرة من السلسلة المحددة. يقوم بتحويل جميع الأحرف الصغيرة إلى أحرف كبيرة. في حالة عدم وجود أحرف صغيرة ، يتم إرجاع السلسلة الأصلية.
معلومات السلسلة -
numpy.count () : تُرجع هذه الدالة عدد مرات حدوث سلسلة فرعية في السلسلة المحددة.

# Python program explaining
# numpy.count() function
 
import numpy as np
 
a=np.array(['geeks', 'for', 'geeks'])
 
# counting a substring
print(np.char.count(a,'geek'))
 
# counting a substring
print(np.char.count(a, 'fo'))
تشغيل على IDE
انتاج :

[1 ، 0 ، 1]
[0 ، 1 ، 0]
 
numpy.rfind () : ترجع هذه الدالة أعلى فهرس للسلسلة الفرعية إذا وجدت في سلسلة معينة. إذا لم يتم العثور عليها ثم تقوم بإرجاع -1.

# Python program explaining
# numpy.rfind() function
 
import numpy as np
 
a=np.array(['geeks', 'for', 'geeks'])
 
# counting a substring
print(np.char.rfind(a,'geek'))
 
# counting a substring
print(np.char.rfind(a, 'fo'))
تشغيل على IDE
انتاج :

[0 ، -1 ، 0]
[-1 ، 0 ، -1]
 
numpy.isnumeric () : ترجع هذه الدالة "True" إذا كانت جميع الأحرف في السلسلة أحرفًا رقمية ، وإلا فإنها ترجع "False".

# Python program explaining
# numpy.isnumeric() function
 
import numpy as np
 
 
# counting a substring
print(np.char.isnumeric('geeks'))
 
# counting a substring
print(np.char.isnumeric('12geeks'))
تشغيل على IDE
انتاج :

خطأ شنيع
خطأ شنيع
 

دور	وصف
numpy.find ()	تقوم بإرجاع أدنى فهرس للسلسلة الفرعية إذا تم العثور عليها في سلسلة معينة. إذا لم يتم العثور عليه فإنه يعيد -1.
numpy.index ()	تقوم بإرجاع موضع التواجد الأول لسلسلة فرعية في سلسلة
numpy.isalpha ()	تقوم بإرجاع "True" إذا كانت جميع الأحرف في السلسلة أبجدية ، وإلا فإنها ترجع "False".
عدد عشري ()	ترجع صحيحًا إذا كانت جميع الأحرف في سلسلة عشرية. إذا لم تكن جميع الأحرف عشرية ، فسيتم إرجاع خطأ.
numpy.isdigit ()	تقوم بإرجاع "True" إذا كانت جميع الأحرف في السلسلة أرقامًا ، وإلا فإنها ترجع "False".
numpy.islower ()	تقوم بإرجاع "True" إذا كانت جميع الأحرف في السلسلة صغيرة ، وإلا فإنها ترجع "False".
numpy.isspace ()	إرجاع صحيح لكل عنصر إذا كان هناك فقط أحرف مسافات بيضاء في السلسلة وكان هناك حرف واحد على الأقل ، خطأ إذا كان العكس.
numpy.istitle ()	تُرجع القيمة true لكل عنصر إذا كان العنصر عبارة عن سلسلة نصية تحتوي على حرف واحد على الأقل ، ويكون الخطأ بخلاف ذلك.
numpy.isupper ()	إرجاع صحيح لكل عنصر إذا كانت جميع الأحرف المغطاة في السلسلة أحرف كبيرة وكان هناك حرف واحد على الأقل ، خطأ إذا كان العكس.
numpy.rindex ()	تُرجع أعلى فهرس للسلسلة الفرعية داخل السلسلة إذا تم العثور على سلسلة فرعية. وإلا فإنه يثير استثناء.
numpy.startswith ()	ترجع صواب إذا بدأت السلسلة بالبادئة المحددة وإلا فإنها ترجع خطأ.
String Comparison -
numpy.equal () : تتحقق هذه الدالة من السلسلة 1 == string2 elementwise.

# Python program explaining
# numpy.equal() function
 
import numpy as np
 
# comparing a string elementwise
# using equal() method
a=np.char.equal('geeks','for')
 
print(a)
تشغيل على IDE
انتاج :

خطأ شنيع
 
numpy.not_equal () : تتحقق هذه الوظيفة مما إذا كانت سلسلتان غير متساويتين أم لا.

# Python program explaining
# numpy.unequal() function
 
import numpy as np
 
# comparing a string elementwise
# using unequal() method
a=np.char.unequal('geeks','for')
 
print(a)
تشغيل على IDE
انتاج :

صحيح
 
numpy.gictures () : تتحقق هذه الوظيفة مما إذا كانت السلسلة 1 أكبر من السلسلة 2 أم لا

# Python program explaining
# numpy.greater() function
 
import numpy as np
 
# comparing a string elementwise
# using greater() method
a=np.char.greater('geeks','for')
 
print(a)
تشغيل على IDE
انتاج :

صحيح
 

دور	وصف
numpy.g Greater_equal ()	يتحقق مما إذا كانت string1> = string2 أم لا.
numpy.less_equal ()	يتحقق ما إذا كانت السلسلة 1 هي <= string2 أم لا.
numpy.less ()	تتحقق مما إذا كانت السلسلة 1 أقل من السلسلة 2 أم لا.


<<<<<<<<<<<<<<<<<<<<<

نومبي | الجبر الخطي
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
توفر وحدة الجبر الخطي في NumPy طرقًا مختلفة لتطبيق الجبر الخطي على أي مصفوفة عددية.
يمكن للمرء أن يجد:

رتبة ، محدد ، تتبع ، وما إلى ذلك من مصفوفة.
قيم المصفوفات eigen
منتجات المصفوفة والمتجهات (نقطة ، داخلية ، خارجية ، إلخ. المنتج) ، أس المصفوفة
حل المعادلات الخطية أو الموتر وأكثر من ذلك بكثير!
# Importing numpy as np
import numpy as np
 
A = np.array([[6, 1, 1],
              [4, -2, 5],
              [2, 8, 7]])
 
# Rank of a matrix
print("Rank of A:", np.linalg.matrix_rank(A))
 
# Trace of matrix A
print("\nTrace of A:", np.trace(A))
 
# Determinant of a matrix
print("\nDeterminant of A:", np.linalg.det(A))
 
# Inverse of matrix A
print("\nInverse of A:\n", np.linalg.inv(A))
 
print("\nMatrix A raised to power 3:\n",
           np.linalg.matrix_power(A, 3))
تشغيل على IDE
انتاج:

رتبة أ: 3

أثر أ: 11

محدد A: -306.0

معكوس أ:
 [[0.17647059 -0.00326797 -0.02287582]
 [0.05882353 -0.13071895 0.08496732]
 [-0.11764706 0.1503268 0.05228758]]

تم رفع المصفوفة A إلى القوة 3:
 [[336162228]
 [406162 469]
 [698702 905]]
 

وظائف قيم المصفوفة الذاتية
numpy.linalg.eigh (a، UPLO = 'L') : تُستخدم هذه الوظيفة لإرجاع القيم الذاتية والمتجهات الذاتية لمصفوفة هيرميتية معقدة (متماثل متماثل) أو مصفوفة متماثلة حقيقية. القيم الذاتية للمصفوفة أو المصفوفة المربعة ثنائية الأبعاد (اعتمادًا على نوع الإدخال) للمتجهات الذاتية المقابلة (في الأعمدة).

# Python program explaining
# eigh() function
 
from numpy import linalg as geek
 
# Creating an array using array 
# function
a = np.array([[1, -2j], [2j, 5]])
 
print("Array is :",a)
 
# calculating an eigen value
# using eigh() function
c, d = geek.eigh(a)
 
print("Eigen value is :", c)
print("Eigen value is :", d)
تشغيل على IDE
انتاج :

المصفوفة هي: [[1. + 0.j، 0.-2.j] ،
                [0. + 2.j، 5. + 0.j]]

قيمة Eigen هي: [0.17157288 ، 5.82842712]

قيمة Eigen هي: [[-0.92387953 + 0.j، -0.38268343 + 0.j] ،
       [0.00000000 + 0.38268343j ، 0.00000000-0.92387953j]]
 
numpy.linalg.eig (a) : تُستخدم هذه الوظيفة لحساب قيم eigenvalues ​​والمتجهات الذاتية اليمنى لمصفوفة مربعة.

# Python program explaining
# eig() function
 
from numpy import linalg as geek
 
# Creating an array using diag 
# function
a = np.diag((1, 2, 3))
 
print("Array is :",a)
 
# calculating an eigen value
# using eig() function
c, d = geek.eig(a)
 
print("Eigen value is :",c)
print("Eigen value is :",d)
تشغيل على IDE
انتاج :

المصفوفة هي: [[1 0 0] ،
                 [0 2 0] ،
                 [0 0 3]]

قيمة Eigen هي: [1 2 3]

القيمة الذاتية هي: [[1 0 0]،
                 [0 1 0] ،
                 [0 0 1]]
 

دور	وصف
linalg.eigvals ()	احسب القيم الذاتية لمصفوفة عامة.
linalg.eigvalsh (a [، UPLO])	احسب القيم الذاتية لمصفوفة هرميتية معقدة أو مصفوفة متماثلة حقيقية.
منتجات المصفوفة والمتجهات
numpy.dot (vector_a، vector_b، out = None) : إرجاع المنتج النقطي للمتجهين a و b. يمكنه التعامل مع المصفوفات ثنائية الأبعاد ولكن اعتبارها مصفوفة وستقوم بضرب المصفوفة. بالنسبة للأبعاد N ، فهي عبارة عن حاصل ضرب على المحور الأخير من المحور الثاني والثاني إلى الأخير من b:

dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m]) 
كود # 1:

# Python Program illustrating
# numpy.dot() method
 
import numpy as geek
 
# Scalars
product = geek.dot(5, 4)
print("Dot Product of scalar values  : ", product)
 
# 1D array
vector_a = 2 + 3j
vector_b = 4 + 5j
 
product = geek.dot(vector_a, vector_b)
print("Dot Product  : ", product)
تشغيل على IDE
انتاج:

حاصل الضرب النقطي للقيم العددية: 20
المنتج النقطي: (-7 + 22j)
 
كيف يعمل كود # 1؟

vector_a = 2 + 3j
vector_b = 4 + 5j

الآن نقطة المنتج
= 2 (4 + 5 ج) + 3 ي (4-5 ج)
                = 8 + 10 ي + 12 ج - 15
                = -7 + 22 ي
 
numpy.vdot (vector_a، vector_b) : إرجاع حاصل الضرب القياسي للمتجهين a و b. إذا كانت الوسيطة الأولى معقدة ، فسيتم استخدام الاقتران المعقد للوسيطة الأولى (هذا هو المكان الذيvdot()يختلف فيه عملdot()الطريقة) لحساب حاصل الضرب القياسي. يمكنه التعامل مع المصفوفات متعددة الأبعاد ولكن العمل عليها كمصفوفة مسطحة.

كود # 1:

# Python Program illustrating
# numpy.vdot() method
 
import numpy as geek
 
# 1D array
vector_a = 2 + 3j
vector_b = 4 + 5j
 
product = geek.vdot(vector_a, vector_b)
print("Dot Product  : ", product)
تشغيل على IDE
انتاج :

المنتج النقطي: (23-2j)
 
كيف يعمل كود # 1؟

vector_a = 2 + 3j
vector_b = 4 + 5j

حسب الطريقة ، خذ مرافق vector_a ie 2 - 3j

الآن حاصل الضرب النقطي = 2 (4 - 5j) + 3j (4 - 5j)
                = 8-10 ج + 12 ج + 15
                = 23 - 2 ي
دور	وصف
matmul ()	حاصل ضرب مصفوفتين.
داخلي()	الناتج الداخلي لمصفوفتين.
خارجي ()	احسب الناتج الخارجي لمتجهين.
linalg.multi_dot ()	احسب حاصل الضرب النقطي لمصفوفتين أو أكثر في استدعاء دالة واحدة ، مع تحديد أسرع ترتيب تقييم تلقائيًا.
تنسوردوت ()	حساب منتج نقطة الموتر على طول المحاور المحددة للمصفوفات> = 1-D.
أينسوم ()	يقيم اتفاقية جمع أينشتاين على المعاملات.
einsum_path ()	يقيّم أمر الانكماش الأقل تكلفة لتعبير einsum من خلال مراعاة إنشاء المصفوفات الوسيطة.
linalg.matrix_power ()	ارفع مصفوفة مربعة للقوة (عدد صحيح) ن.
كرون ()	ناتج كرونيكر من صفيفتين.
حل المعادلات وعكس المصفوفات
numpy.linalg.solve () : حل معادلة مصفوفة خطية أو نظام معادلات عددية خطية. يحسب الحل "الدقيق" x للمعادلة المحددة جيدًا ، أي الدرجة الكاملة ، معادلة المصفوفة الخطية ax = b.

# Python Program illustrating
# numpy.linalg.solve() method
 
import numpy as np
 
# Creating an array using array
# function
a = np.array([[1, 2], [3, 4]])
 
# Creating an array using array
# function
b = np.array([8, 18])
 
print(("Solution of linear equations:", 
      np.linalg.solve(a, b)))
تشغيل على IDE
انتاج:

حل المعادلات الخطية: [2. 3.]
 
numpy.linalg.lstsq () : إرجاع حل المربعات الصغرى إلى معادلة مصفوفة خطية. يحل المعادلة ax = b بحساب المتجه x الذي يصغر القاعدة الإقليدية 2 || ب - فأس || ^ 2 . قد تكون المعادلة ناقصة أو جيدة أو مفرطة التحديد (على سبيل المثال ، يمكن أن يكون عدد الصفوف المستقلة خطيًا لـ a أقل من أو يساوي أو أكبر من عدد الأعمدة المستقلة خطيًا). إذا كانت a مربعة وذات رتبة كاملة ، فإن x (لكن لخطأ التقريب) هي الحل "الدقيق" للمعادلة.

# Python Program illustrating
# numpy.linalg.lstsq() method
 
 
import numpy as np
import matplotlib.pyplot as plt
 
# x co-ordinates
x = np.arange(0, 9)
A = np.array([x, np.ones(9)])
 
# linearly generated sequence
y = [19, 20, 20.5, 21.5, 22, 23, 23, 25.5, 24]
# obtaining the parameters of regression line
w = np.linalg.lstsq(A.T, y)[0] 
 
# plotting the line
line = w[0]*x + w[1] # regression line
plt.plot(x, line, 'r-')
plt.plot(x, y, 'o')
plt.show()
تشغيل على IDE
انتاج:

4

دور	وصف
numpy.linalg.tensorsolve ()	حل معادلة الموتر ax = b من أجل x.
numpy.linalg.inv ()	احسب المعكوس (الضربي) لمصفوفة.
numpy.linalg.pinv ()	احسب (Moore-Penrose) المقلوب الزائف لمصفوفة.
numpy.linalg.tensorinv ()	احسب "معكوس" مصفوفة ذات أبعاد N.
وظائف خاصة
numpy.linalg.det () : حساب محدد المصفوفة.

# Python Program illustrating
# numpy.linalg.det() method
 
import numpy as np
 
# creating an array using 
# array method
A = np.array([[6, 1, 1],
              [4, -2, 5],
              [2, 8, 7]])
 
 
print(("\nDeterminant of A:"
     , np.linalg.det(A)))
تشغيل على IDE
انتاج:

محدد A: -306.0
 
numpy.trace () : إرجاع المجموع على طول أقطار المصفوفة. إذا كان a 2-D ، يتم إرجاع المجموع على طول قطريها مع الإزاحة المحددة ، أي مجموع العناصر a [i، i + offset] للجميع i إذا كان a يحتوي على أكثر من بعدين ، فسيتم استخدام المحاور المحددة بواسطة المحور 1 والمحور 2 لتحديد المصفوفات الفرعية ثنائية الأبعاد التي يتم إرجاع آثارها. شكل الصفيف الناتج هو نفسه شكل a مع إزالة المحور 1 والمحور 2.

# Python Program illustrating
# numpy.trace()() method
 
import numpy as np
 
# creating an array using 
# array method
A = np.array([[6, 1, 1],
              [4, -2, 5],
              [2, 8, 7]])
 
 
print("\nTrace of A:", np.trace(A))
تشغيل على IDE
انتاج:

أثر أ: 11
 

دور	وصف
numpy.linalg.norm ()	مصفوفة أو قاعدة ناقلات.
numpy.linalg.cond ()	احسب رقم شرط المصفوفة.
numpy.linalg.matrix_rank ()	إرجاع رتبة مصفوفة باستخدام طريقة SVD
numpy.linalg.cholesky ()	تحلل تشوليسكي.
numpy.linalg.qr ()	حساب عامل qr لمصفوفة.
numpy.linalg.svd ()	تحليل القيمة الفردية.

<<<<<<<<<<<<<<<<<<<<<
نومبي | الفرز والبحث والعد
تاريخ التحديث الأخير: 15 تشرين الثاني (نوفمبر) 2018
فرز
يشير الفرز إلى ترتيب البيانات بتنسيق معين. تحدد خوارزمية الفرز طريقة ترتيب البيانات بترتيب معين. تكون الطلبات الأكثر شيوعًا بالترتيب العددي أو المعجمي. في Numpy ، يمكننا إجراء عمليات فرز مختلفة باستخدام الوظائف المختلفة المتوفرة في المكتبة مثل Sort و lexsort و argsort وما إلى ذلك.

numpy.sort () : ترجع هذه الدالة نسخة مرتبة من مصفوفة.

# importing libraries
import numpy as np
 
# sort along the first axis
a = np.array([[12, 15], [10, 1]])
arr1 = np.sort(a, axis = 0)        
print ("Along first axis : \n", arr1)        
 
 
# sort along the last axis
a = np.array([[10, 15], [12, 1]])
arr2 = np.sort(a, axis = -1)        
print ("\nAlong first axis : \n", arr2)
 
 
a = np.array([[12, 15], [10, 1]])
arr1 = np.sort(a, axis = None)        
print ("\nAlong none axis : \n", arr1)
تشغيل على IDE
انتاج :

على طول المحور الأول:
 [[10 1]
 [12 - 15]

على طول المحور الأول:
 [[10 - 15]
 [1 12]

على طول أي محور:
 [1 10 12 15]
 
numpy.argsort () : تعرض هذه الدالة المؤشرات التي من شأنها فرز مصفوفة.

# Python code to demonstrate 
# working of  numpy.argsort
import numpy as np
 
# Numpy array created
a = np.array([9, 3, 1, 7, 4, 3, 6])
 
# unsorted array print
print('Original array:\n', a)
 
# Sort array indices
b = np.argsort(a)
print('Sorted indices of original array->', b)
 
# To get sorted array using sorted indices
# c is temp array created of same len as of b
c = np.zeros(len(b), dtype = int)
for i in range(0, len(b)):
    c[i]= a[b[i]]
print('Sorted array->', c)
تشغيل على IDE
انتاج:

المجموعة الأصلية:
 [9 3 1 7 4 3 6]
الفهارس المصنفة للمصفوفة الأصلية-> [2 1 5 4 6 3 0]
مصفوفة مرتبة-> [1 3 3 4 6 7 9]
 
numpy.lexsort () : تقوم هذه الوظيفة بإرجاع فرز مستقر غير مباشر باستخدام سلسلة من المفاتيح.

# Python code to demonstrate working of 
# numpy.lexsort()
import numpy as np
 
# Numpy array created
# First column
a = np.array([9, 3, 1, 3, 4, 3, 6])
 
# Second column 
b = np.array([4, 6, 9, 2, 1, 8, 7]) 
print('column a, column b')
for (i, j) in zip(a, b):
    print(i, ' ', j)
 
# Sort by a then by b
ind = np.lexsort((b, a)) 
print('Sorted indices->', ind)
تشغيل على IDE
انتاج :

العمود أ ، العمود ب
9 4
3 6
1 9
3 2
4 1
3 8
6 7
المؤشرات المصنفة-> [2 3 1 5 4 6 0]
 

دور	وصف
numpy.ndarray.sort ()	فرز مصفوفة في المكان.
numpy.msort ()	قم بإرجاع نسخة من مصفوفة تم فرزها على طول المحور الأول.
numpy.sort_complex ()	افرز مصفوفة معقدة باستخدام الجزء الحقيقي أولاً ، ثم الجزء التخيلي.
numpy.partition ()	إرجاع نسخة مقسمة من المصفوفة.
numpy.argpartition ()	قم بإجراء قسم غير مباشر على طول المحور المحدد باستخدام الخوارزمية المحددة بواسطة الكلمة الأساسية الرقيقة.
يبحث
البحث عملية أو تقنية تساعد في العثور على مكان عنصر أو قيمة معينة في القائمة. يُقال إن أي بحث يكون ناجحًا أو غير ناجح اعتمادًا على ما إذا كان العنصر الذي يتم البحث عنه قد تم العثور عليه أم لا. في Numpy ، يمكننا إجراء عمليات بحث متنوعة باستخدام الوظائف المختلفة المتوفرة في المكتبة مثل argmax و argmin و nanaargmax وما إلى ذلك.

numpy.argmax () : ترجع هذه الدالة مؤشرات الحد الأقصى لعنصر المصفوفة في محور معين.

# Python Program illustrating
# working of argmax()
 
import numpy as geek 
 
# Working on 2D array
array = geek.arange(12).reshape(3, 4)
print("INPUT ARRAY : \n", array)
 
# No axis mentioned, so works on entire array
print("\nMax element : ", geek.argmax(array))
 
# returning Indices of the max element
# as per the indices
print(("\nIndices of Max element : "
      , geek.argmax(array, axis=0)))
print(("\nIndices of Max element : "
      , geek.argmax(array, axis=1)))
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [[0 1 2 3]
 [4 5 6 7]
 [8 9 10 11]]

الحد الأقصى للعنصر: 11

مؤشرات الحد الأقصى للعنصر: [2 2 2 2]

مؤشرات الحد الأقصى للعنصر: [3 3 3]
 
numpy.nanargmax () : تعرض هذه الدالة مؤشرات لأقصى عنصر من المصفوفة في محور معين مع تجاهل NaNs. لا يمكن الوثوق بالنتائج إذا كانت الشريحة تحتوي على NaNs و Infs فقط.

# Python Program illustrating
# working of nanargmax()
 
import numpy as geek 
 
# Working on 1D array
array = [geek.nan, 4, 2, 3, 1]
print("INPUT ARRAY 1 : \n", array)
 
array2 = geek.array([[geek.nan, 4], [1, 3]])
 
# returning Indices of the max element
# as per the indices ingnoring NaN
print(("\nIndices of max in array1 : "
       , geek.nanargmax(array)))
 
# Working on 2D array
print("\nINPUT ARRAY 2 : \n", array2)
print(("\nIndices of max in array2 : "
      , geek.nanargmax(array2)))
 
print(("\nIndices at axis 1 of array2 : "
      , geek.nanargmax(array2, axis = 1)))
تشغيل على IDE
انتاج :

صفيف الإدخال 1:
 [nan، 4، 2، 3، 1]

مؤشرات الحد الأقصى في المصفوفة 1: 1

صفيف الإدخال 2:
 [[نان 4.]
 [1. 3.]]

مؤشرات الحد الأقصى في المصفوفة 2: 1

الفهارس في المحور 1 للمصفوفة 2: [1 1]
 
numpy.argmin () : ترجع هذه الدالة مؤشرات القيم الدنيا على طول المحور.

# Python Program illustrating
# working of argmin()
 
import numpy as geek 
 
# Working on 1D array
array = geek.arange(8)
print("INPUT ARRAY : \n", array)
 
 
# returning Indices of the min element
# as per the indices
print("\nIndices of min element : ", geek.argmin(array, axis=0))
تشغيل على IDE
انتاج :

صفيف الإدخال:
 [0 1 2 3 4 5 6 7]

مؤشرات عنصر min: 0
 

دور	وصف
numpy.nanargmin ()	قم بإرجاع مؤشرات القيم الدنيا في المحور المحدد مع تجاهل NaNs.
numpy.argwhere ()	ابحث عن مؤشرات عناصر المصفوفة غير الصفرية ، مجمعة حسب العنصر.
numpy.nonzero ()	قم بإرجاع فهارس العناصر غير الصفرية.
numpy.flatnonzero ()	قم بإرجاع الفهارس غير الصفرية في النسخة المسطحة من a.
numpy.where ()	إرجاع العناصر المختارة من x أو y حسب الحالة.
numpy.searchsorted ()	ابحث عن الفهارس حيث يجب إدراج العناصر للحفاظ على النظام.
numpy.extract ()	إعادة عناصر المصفوفة التي تحقق شرطًا ما.
عد
numpy.count_nonzero () : تحسب عدد القيم غير الصفرية في المصفوفة.

# Python Program illustrating
# working of count_nonzero()
 
import numpy as np
  
# Counting a number of 
# non-zero values
a = np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
b = np.count_nonzero(([[0,1,7,0,0],[3,0,0,2,19]]
                     , axis=0))
 
print("Number of nonzero values is :",a)
print("Number of nonzero values is :",b)
تشغيل على IDE
انتاج :

عدد القيم غير الصفرية: 5
عدد القيم غير الصفرية: [1 ، 1 ، 1 ، 1 ، 1]
 
<<<<<<<<<<<<<<<<<<<<<
أخذ عينات عشوائي في numpy | وظيفة randint ()
مستوى الصعوبة: أساسي
تاريخ التحديث الأخير: 26 فبراير 2019
numpy.random.randint()هي إحدى وظائف القيام بأخذ عينات عشوائية في numpy. تقوم بإرجاع مصفوفة من الأشكال المحددة وتعبئتها بأعداد صحيحة عشوائية من منخفض (شامل) إلى مرتفع (حصري) ، أي في الفاصل الزمني[low, high).

بناء الجملة: numpy.random.randint (منخفض ، مرتفع = لا شيء ، الحجم = لا شيء ، النوع dtype = 'l')

المعلمات:
منخفض: [int] أدنى عدد صحيح (علامة) يتم رسمه من التوزيع ، لكنه يعمل كأعلى عدد صحيح في العينة إذا كان مرتفعًا = لا شيء.
مرتفع: [int ، اختياري] أكبر عدد صحيح (موقع) يتم استخلاصه من التوزيع.
الحجم: [int أو tuple of ints ، اختياري] شكل الإخراج. إذا كان الشكل المحدد ، على سبيل المثال ، (م ، ن ، ك) ، فسيتم رسم عينات م * ن * ك. الافتراضي هو لا شيء ، وفي هذه الحالة يتم إرجاع قيمة واحدة.
نوع البيانات: [اختياري] نوع بيانات الإخراج المرغوب.

العودة: صفيف من الأعداد الصحيحة العشوائية في الفاصل الزمني [low, high)أو عدد صحيح واحد عشوائي إذا لم يتم توفير الحجم.

كود # 1:


# Python program explaining
# numpy.random.randint() function
  
# importing numpy
import numpy as geek
  
# output array
out_arr = geek.random.randint(low = 0, high = 3, size = 5)
print ("Output 1D Array filled with random integers : ", out_arr) 
انتاج :
مصفوفة إخراج 1D مليئة بأعداد صحيحة عشوائية: [1 1 0 1 1]
 

كود # 2:


# Python program explaining
# numpy.random.randint() function
  
# importing numpy
import numpy as geek
  
  
# output array
out_arr = geek.random.randint(low = 4, size =(2, 3))
print ("Output 2D Array filled with random integers : ", out_arr) 
انتاج :
مصفوفة إخراج ثنائية الأبعاد مليئة بأعداد صحيحة عشوائية: [[1 1 0]
 [1 0 3]]
 
كود # 3:


# Python program explaining
# numpy.random.randint() function
  
# importing numpy
import numpy as geek
  
# output array
out_arr = geek.random.randint(2, 10, (2, 3, 4))
print ("Output 3D Array filled with random integers : ", out_arr) 
انتاج :
مصفوفة إخراج ثلاثية الأبعاد مليئة بأعداد صحيحة عشوائية: [[[4 8 5 7]
  [6 5 6 7]
  [4 3 4 3]]

 [[2 9 2 2]
  [3 2 2 3]
  [6 8 3 2]]

<<<<<<<<<<<<<<<<<<<<<
أخذ عينات عشوائي في numpy | دالة random_sample ()
تاريخ التحديث الأخير: 26 فبراير 2019
numpy.random.random_sample()هي إحدى وظائف القيام بأخذ عينات عشوائية في numpy. تقوم بإرجاع مصفوفة من الأشكال المحددة وتعبئتها بعوامات عشوائية في فاصل نصف مفتوح[0.0, 1.0).

بناء الجملة: numpy.random.random_sample (الحجم = لا شيء)

المعلمات:
الحجم: [int أو tuple of ints ، اختياري] شكل الإخراج. إذا كان الشكل المحدد ، على سبيل المثال ، (م ، ن ، ك) ، فسيتم رسم عينات م * ن * ك. الافتراضي هو لا شيء ، وفي هذه الحالة يتم إرجاع قيمة واحدة.

الإرجاع: مصفوفة من العوامات العشوائية في الفاصل الزمني [0.0, 1.0).أو عوامة عشوائية واحدة إذا لم يتم توفير الحجم.

كود # 1:


# Python program explaining
# numpy.random.sample() function
  
# importing numpy
import numpy as geek
  
# output random value
out_val = geek.random.random_sample()
print ("Output random float value : ", out_val) 
انتاج :
قيمة تعويم الإخراج العشوائي: 0.9211987310893188
 

كود # 2:


# Python program explaining
# numpy.random.random_sample() function
  
# importing numpy
import numpy as geek
  
  
# output array
out_arr = geek.random.random_sample(size =(1, 3))
print ("Output 2D Array filled with random floats : ", out_arr) 
انتاج :
مصفوفة إخراج ثنائية الأبعاد مليئة بعوامات عشوائية: [[0.64325146 0.4699456 0.89895437]]
 
كود # 3:


# Python program explaining
# numpy.random.random_sample() function
  
# importing numpy
import numpy as geek
  
# output array
out_arr = geek.random.random_sample((3, 2, 1))
print ("Output 3D Array filled with random floats : ", out_arr) 
انتاج :
مصفوفة إخراج ثلاثية الأبعاد مليئة بعوامات عشوائية: [[[0.78245025]
  [0.77736746]]

 [[0.54389267]
  [0.18491758]]

 [[0.97428409]
  [0.73729256]]]

<<<<<<<<<<<<<<<<<<<<<
أخذ عينات عشوائي في numpy | ranf () وظيفة
تاريخ التحديث الأخير: 26 فبراير 2019
numpy.random.ranf()هي إحدى وظائف القيام بأخذ عينات عشوائية في numpy. تقوم بإرجاع مصفوفة من الأشكال المحددة وتعبئتها بعوامات عشوائية في فاصل نصف مفتوح[0.0, 1.0).

بناء الجملة: numpy.random.ranf (الحجم = لا شيء)

المعلمات:
الحجم: [int أو tuple of ints ، اختياري] شكل الإخراج. إذا كان الشكل المحدد ، على سبيل المثال ، (م ، ن ، ك) ، فسيتم رسم عينات م * ن * ك. الافتراضي هو لا شيء ، وفي هذه الحالة يتم إرجاع قيمة واحدة.

الإرجاع: مصفوفة من العوامات العشوائية في الفاصل الزمني [0.0, 1.0).أو عوامة عشوائية واحدة إذا لم يتم توفير الحجم.

كود # 1:


# Python program explaining
# numpy.random.ranf() function
  
# importing numpy
import numpy as geek
  
  
# output random float value
out_val = geek.random.ranf()
print ("Output random float value : ", out_val) 
انتاج :
قيمة تعويم الإخراج العشوائي: 0.0877051588430926
 

كود # 2:


# Python program explaining
# numpy.random.ranf() function
  
# importing numpy
import numpy as geek
  
  
# output array
out_arr = geek.random.ranf(size =(2, 1))
print ("Output 2D Array filled with random floats : ", out_arr) 
انتاج :
مصفوفة الإخراج ثنائية الأبعاد مليئة بعوامات عشوائية: [[0.14186407]
 [0.58068259]]
 
كود # 3:


# Python program explaining
# numpy.random.ranf() function
  
# importing numpy
import numpy as geek
  
# output array
out_arr = geek.random.ranf((3, 3, 2))
print ("Output 3D Array filled with random floats : ", out_arr) 
انتاج :
مصفوفة إخراج ثلاثية الأبعاد مليئة بعوامات عشوائية: [[[0.11013584 0.67844746]
  [0.84691569 0.09467084]
  [0.69918864 0.12137178]]

 [[0.30629051 0.28301093]
  [0.1302665 0.2196221]
  [0.51555358 0.73191852]]

 [[0.72806359 0.66485275]
  [0.80654791 0.04947181]
  [0.06380535 0.99306064]]]


<<<<<<<<<<<<<<<<<<<<<
أخذ عينات عشوائي في numpy | دالة عشوائية ()
مستوى الصعوبة: متوسط
تاريخ التحديث الأخير: 26 فبراير 2019
numpy.random.random_integers()هي إحدى وظائف القيام بأخذ عينات عشوائية في numpy. تقوم بإرجاع مصفوفة من الأشكال المحددة وتعبئتها بأعداد صحيحة عشوائية من منخفض (شامل) إلى مرتفع (حصري) ، أي في الفاصل الزمني[low, high).

التركيب اللغوي: numpy.random.random_integers (منخفض ، مرتفع = لا شيء ، الحجم = لا شيء)

المعلمات:
منخفض: [int] أدنى عدد صحيح (علامة) يتم رسمه من التوزيع ، لكنه يعمل كأعلى عدد صحيح في العينة إذا كان مرتفعًا = لا شيء.
مرتفع: [int ، اختياري] أكبر عدد صحيح (موقع) يتم استخلاصه من التوزيع.
الحجم: [int أو tuple of ints ، اختياري] شكل الإخراج. إذا كان الشكل المحدد ، على سبيل المثال ، (م ، ن ، ك) ، فسيتم رسم عينات م * ن * ك. الافتراضي هو لا شيء ، وفي هذه الحالة يتم إرجاع قيمة واحدة.

العودة: صفيف من الأعداد الصحيحة العشوائية في الفاصل الزمني [low, high)أو عدد صحيح واحد عشوائي إذا لم يتم توفير الحجم.

كود # 1:


# Python program explaining
# numpy.random.random_integers() function
  
# importing numpy
import numpy as geek
  
# output array
out_arr = geek.random.random_integers(low = 0, high = 5, size = 4)
print ("Output 1D Array filled with random integers : ", out_arr) 
انتاج :
مصفوفة إخراج 1D مليئة بأعداد صحيحة عشوائية: [1 1 4 1]
 

كود # 2:


# Python program explaining
# numpy.random.random_integers() function
  
# importing numpy
import numpy as geek
  
  
# output array
out_arr = geek.random.random_integers(low = 3, size =(3, 3))
print ("Output 2D Array filled with random integers : ", out_arr) 
انتاج :
صفيف الإخراج ثنائي الأبعاد مليء بأعداد صحيحة عشوائية: [[2 3 1]
 [2 2 3]
 [3 3 3]]
 
كود # 3:


# Python program explaining
# numpy.random.random_integers() function
  
# importing numpy
import numpy as geek
  
# output array
out_arr = geek.random.random_integers(1, 6, (2, 2, 3))
print ("Output 3D Array filled with random integers : ", out_arr) 
انتاج :
مصفوفة إخراج ثلاثية الأبعاد مليئة بأعداد صحيحة عشوائية: [[[4 8 5 7]
مصفوفة إخراج ثلاثية الأبعاد مليئة بأعداد صحيحة عشوائية: [[[5 1 5]
  [5 4 1]]

 [[3 6 4]
  [4 5 3]]
<<<<<<<<<<<<<<<<<<<<<

نومبي ufunc | وظائف عالمية
تاريخ التحديث الأخير: 21 يوليو 2021
الدوال العامة في Numpy هي دوال رياضية بسيطة. إنه مجرد مصطلح أطلقناه للوظائف الرياضية في مكتبة Numpy. يوفر Numpy وظائف عالمية متنوعة تغطي مجموعة متنوعة من العمليات. 
تتضمن هذه الوظائف الدوال المثلثية القياسية ، ووظائف العمليات الحسابية ، والتعامل مع الأرقام المعقدة ، والوظائف الإحصائية ، وما إلى ذلك. للوظائف العامة خصائص مختلفة على النحو التالي: 
 

تعمل هذه الوظائف على ndarray (مصفوفة الأبعاد N) أي فئة مصفوفة Numpy.
ينفذ عمليات مجموعة سريعة من حيث العناصر.
وهو يدعم ميزات مختلفة مثل بث المصفوفة ونوع الصب وما إلى ذلك.
Numpy ، الوظائف العامة هي كائنات تنتمي إلى فئة numpy.ufunc.
يمكن أيضًا إنشاء وظائف Python كوظيفة عالمية باستخدام وظيفة مكتبة frompyfunc .
يتم استدعاء بعض ufuncs تلقائيًا عند استخدام المعامل الحسابي المقابل في المصفوفات. على سبيل المثال ، عند إضافة مصفوفتين من حيث العناصر باستخدام عامل التشغيل "+" ، يتم استدعاء np.add () داخليًا.
بعض الوظائف العامة الأساسية في Numpy هي-
 

الدوال المثلثية:
تعمل هذه الدوال على الراديان ، لذلك يجب تحويل الزوايا إلى راديان بضربها في pi / 180. عندها فقط يمكننا استدعاء الدوال المثلثية. يأخذون مصفوفة كمدخلات من الحجج. يتضمن وظائف مثل-

دور	وصف
الخطيئة ، كوس ، تان	حساب الجيب وجيب التمام وظل الزوايا
arcsin ، arccos ، arctan	حساب الجيب العكسي وجيب التمام والظل
hypot	احسب وتر المثلث القائم الزاوية
سينه ، كوش ، تانه	حساب الجيب الزائدي وجيب التمام والظل
أركسينه ، أركوش ، أركتانه	حساب الجيب الزائدي العكسي وجيب التمام والظل
deg2rad	تحويل الدرجة إلى راديان
rad2deg	تحويل الراديان إلى درجة
 


# Python code to demonstrate trigonometric function
import numpy as np
  
# create an array of angles
angles = np.array([0, 30, 45, 60, 90, 180]) 
  
# conversion of degree into radians
# using deg2rad function
radians = np.deg2rad(angles)
  
# sine of angles
print('Sine of angles in the array:')
sine_value = np.sin(radians)
print(np.sin(radians))
  
# inverse sine of sine values
print('Inverse Sine of sine values:')
print(np.rad2deg(np.arcsin(sine_value)))
  
# hyperbolic sine of angles
print('Sine hyperbolic of angles in the array:')
sineh_value = np.sinh(radians)
print(np.sinh(radians))
  
# inverse sine hyperbolic 
print('Inverse Sine hyperbolic:')
print(np.sin(sineh_value)) 
  
# hypot function demonstration
base = 4
height = 3
print('hypotenuse of right triangle is:')
print(np.hypot(base, height))
انتاج: 
جيب الزاوية في المصفوفة:
[0.00000000e + 00 5.00000000e-01 7.07106781e-01 8.66025404e-01
   1.00000000e + 00 1.22464680e-16]

الجيب المعكوس لقيم الجيب:
[0.00000000e + 00 3.00000000e + 01 4.50000000e + 01 6.00000000e + 01
   9.00000000e + 01 7.01670930e-15]

جيب قطعي للزوايا في المصفوفة:
[0. 0.54785347 0.86867096 1.24936705 2.3012989
  11.54873936]

معكوس الجيب القطعي:
[0. 0.52085606 0.76347126 0.94878485 0.74483916 -0.85086591]

وتر المثلث قائم الزاوية هو:
5.0
 

الوظائف الإحصائية:
تُستخدم هذه الوظائف لحساب المتوسط ​​والوسيط والتباين والحد الأدنى لعناصر المصفوفة. يتضمن وظائف مثل-
 

دور	وصف
أمين ، أماكس	إرجاع الحد الأدنى أو الحد الأقصى لصفيف أو على طول المحور
ptp	يُرجع نطاقًا من القيم (الحد الأقصى - الحد الأدنى) لصفيف أو على طول المحور
النسبة المئوية (أ ، ف ، محور)	حساب النسبة المئوية pth للصفيف أو على طول المحور المحدد
الوسيط	حساب متوسط ​​البيانات على طول المحور المحدد
يعني	متوسط ​​حساب البيانات على طول المحور المحدد
الأمراض المنقولة جنسيا	حساب الانحراف المعياري للبيانات على طول المحور المحدد
فار	حساب تباين البيانات على طول المحور المحدد
معدل	متوسط ​​حساب البيانات على طول المحور المحدد
 


# Python code demonstrate statistical function
import numpy as np
  
# construct a weight array
weight = np.array([50.7, 52.5, 50, 58, 55.63, 73.25, 49.5, 45])
  
# minimum and maximum 
print('Minimum and maximum weight of the students: ')
print(np.amin(weight), np.amax(weight))
  
# range of weight i.e. max weight-min weight
print('Range of the weight of the students: ')
print(np.ptp(weight))
  
# percentile
print('Weight below which 70 % student fall: ')
print(np.percentile(weight, 70))
   
# mean 
print('Mean weight of the students: ')
print(np.mean(weight))
  
# median 
print('Median weight of the students: ')
print(np.median(weight))
  
# standard deviation 
print('Standard deviation of weight of the students: ')
print(np.std(weight))
  
# variance 
print('Variance of weight of the students: ')
print(np.var(weight))
  
# average 
print('Average weight of the students: ')
print(np.average(weight))
انتاج: 
الوزن الأدنى والأقصى للطلاب:
45.0 73.25

نطاق وزن الطلاب:
28.25

الوزن الذي يقل عن 70٪ من الطلاب:
55.317

متوسط ​​وزن الطلاب:
54.3225

الوزن الوسطي للطلاب:
51.6

الانحراف المعياري لوزن الطلاب:
8.05277397857

تباين وزن الطلاب:
64.84716875

متوسط ​​وزن الطلاب:
54.3225
 

وظائف twiddling بت:
تقبل هذه الدوال قيم الأعداد الصحيحة كوسائط إدخال وتنفذ عمليات بت على التمثيلات الثنائية لتلك الأعداد الصحيحة. تتضمن وظائف مثل-
 

دور	وصف
bitwise_and	ينفذ أحادي المعامل ويعمل على عنصرين من الصفيف
bitwies_or	ينفذ أحادي المعامل أو العملية على عنصرين من الصفيف
bitwise_xor	ينفذ عملية bitwise xor على عنصرين من الصفيف
عكس	ينفذ انعكاس أحادي لعناصر المصفوفة
التحول الأيسر	انقل أجزاء العناصر إلى اليسار
النقلة الصحيحة	انقل أجزاء العناصر إلى اليسار
 


# Python code to demonstrate bitwise-function
import numpy as np
  
# construct an array of even and odd numbers
even = np.array([0, 2, 4, 6, 8, 16, 32])
odd = np.array([1, 3, 5, 7, 9, 17, 33])
  
# bitwise_and
print('bitwise_and of two arrays: ')
print(np.bitwise_and(even, odd))
  
# bitwise_or
print('bitwise_or of two arrays: ')
print(np.bitwise_or(even, odd))
  
# bitwise_xor
print('bitwise_xor of two arrays: ')
print(np.bitwise_xor(even, odd))
   
# invert or not
print('inversion of even no. array: ')
print(np.invert(even))
  
# left_shift 
print('left_shift of even no. array: ')
print(np.left_shift(even, 1))
  
# right_shift 
print('right_shift of even no. array: ')
print(np.right_shift(even, 1))
انتاج: 
bitwise_and من صفيفتين:
[0 2 4 6 8 16 32]

bitwise_or من صفيفتين:
[1 3 5 7 9 17 33]

bitwise_xor لمصفوفتين:
[1 1 1 1 1 1 1]

عكس حتى لا. مجموعة مصفوفة:
[-1 -3 -5 -7 -9 -17 -33]

إزاحة اليسار حتى لا. مجموعة مصفوفة:
[0 4 8 12 16 32 64]

التحول الأيمن حتى لا. مجموعة مصفوفة:
[0 1 2 3 4 8 16]